{"ast":null,"code":"import { GPSService } from './gps';\nexport class RoutingService {\n  // Free tier key - replace with your own\n\n  // Get a real walking route between two points\n  static async getWalkingRoute(start, end, calmZones, stressZones) {\n    try {\n      // First, get the basic route from OpenRouteService\n      const basicRoute = await this.getBasicRoute(start, end);\n\n      // Then optimize it based on calm/stress zones\n      const optimizedRoute = await this.optimizeRoute(basicRoute, calmZones, stressZones);\n      return optimizedRoute;\n    } catch (error) {\n      console.error('Routing error:', error);\n      // Fallback to simple straight-line route\n      return this.createFallbackRoute(start, end, calmZones, stressZones);\n    }\n  }\n\n  // Get basic route from OpenRouteService\n  static async getBasicRoute(start, end) {\n    try {\n      const response = await axios.get(this.OPENROUTE_API_URL, {\n        params: {\n          api_key: this.API_KEY,\n          start: `${start.longitude},${start.latitude}`,\n          end: `${end.longitude},${end.latitude}`,\n          profile: 'foot-walking',\n          format: 'json',\n          instructions: true,\n          geometry: true\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.warn('OpenRouteService failed, trying GraphHopper...', error);\n      return await this.getGraphHopperRoute(start, end);\n    }\n  }\n\n  // Fallback to GraphHopper (free tier)\n  static async getGraphHopperRoute(start, end) {\n    try {\n      var _route$instructions;\n      const response = await axios.get('https://graphhopper.com/api/1/route', {\n        params: {\n          key: 'demo',\n          // Free demo key\n          point: [`${start.latitude},${start.longitude}`, `${end.latitude},${end.longitude}`],\n          vehicle: 'foot',\n          instructions: true,\n          points_encoded: false\n        }\n      });\n\n      // Convert GraphHopper format to our expected format\n      const route = response.data.paths[0];\n      return {\n        features: [{\n          geometry: {\n            coordinates: route.points.coordinates\n          },\n          properties: {\n            summary: {\n              distance: route.distance,\n              duration: route.time / 1000 // Convert ms to seconds\n            },\n            instructions: ((_route$instructions = route.instructions) === null || _route$instructions === void 0 ? void 0 : _route$instructions.map(inst => ({\n              instruction: inst.text,\n              distance: inst.distance\n            }))) || []\n          }\n        }]\n      };\n    } catch (error) {\n      console.warn('GraphHopper also failed, using fallback route', error);\n      throw new Error('All routing services failed');\n    }\n  }\n\n  // Optimize route based on calm/stress zones\n  static async optimizeRoute(basicRoute, calmZones, stressZones) {\n    const route = basicRoute.features[0];\n    const geometry = route.geometry.coordinates;\n    const properties = route.properties;\n\n    // Convert coordinates to our format\n    const waypoints = geometry.map(coord => ({\n      longitude: coord[0],\n      latitude: coord[1]\n    }));\n\n    // Create route segments\n    const segments = [];\n    for (let i = 0; i < waypoints.length - 1; i++) {\n      const start = waypoints[i];\n      const end = waypoints[i + 1];\n      const distance = GPSService.calculateDistance({\n        latitude: start.latitude,\n        longitude: start.longitude,\n        timestamp: 0\n      }, {\n        latitude: end.latitude,\n        longitude: end.longitude,\n        timestamp: 0\n      });\n      segments.push({\n        start,\n        end,\n        distance,\n        duration: distance / 1.4 // Average walking speed: 1.4 m/s\n      });\n    }\n\n    // Calculate calm score and zone interactions\n    const {\n      calmScore,\n      avoidsStressZones,\n      includesCalmZones\n    } = this.analyzeRouteOptimization(waypoints, calmZones, stressZones);\n\n    // Generate instructions\n    const instructions = this.generateInstructions(segments, properties.instructions || []);\n    return {\n      id: `route_${Date.now()}`,\n      start: {\n        latitude: waypoints[0].latitude,\n        longitude: waypoints[0].longitude,\n        timestamp: 0\n      },\n      end: {\n        latitude: waypoints[waypoints.length - 1].latitude,\n        longitude: waypoints[waypoints.length - 1].longitude,\n        timestamp: 0\n      },\n      waypoints,\n      segments,\n      totalDistance: properties.summary.distance,\n      totalDuration: properties.summary.duration,\n      calmScore,\n      avoidsStressZones,\n      includesCalmZones,\n      instructions\n    };\n  }\n\n  // Analyze route optimization based on calm/stress zones\n  static analyzeRouteOptimization(waypoints, calmZones, stressZones) {\n    let calmScore = 0.5; // Base score\n    const avoidsStressZones = [];\n    const includesCalmZones = [];\n\n    // Check each waypoint against zones\n    waypoints.forEach(point => {\n      const pointLocation = {\n        latitude: point.latitude,\n        longitude: point.longitude,\n        timestamp: 0\n      };\n\n      // Check stress zones\n      stressZones.forEach(zone => {\n        if (GPSService.isWithinRadius(zone.center, pointLocation, zone.radius)) {\n          calmScore -= 0.1; // Penalize for going through stress zones\n          if (!avoidsStressZones.includes(zone.id)) {\n            avoidsStressZones.push(zone.id);\n          }\n        }\n      });\n\n      // Check calm zones\n      calmZones.forEach(zone => {\n        if (GPSService.isWithinRadius(zone.center, pointLocation, zone.radius)) {\n          calmScore += 0.05; // Reward for going through calm zones\n          if (!includesCalmZones.includes(zone.id)) {\n            includesCalmZones.push(zone.id);\n          }\n        }\n      });\n    });\n\n    // Normalize calm score to 0-1 range\n    calmScore = Math.max(0, Math.min(1, calmScore));\n    return {\n      calmScore,\n      avoidsStressZones,\n      includesCalmZones\n    };\n  }\n\n  // Generate human-readable instructions\n  static generateInstructions(segments, apiInstructions) {\n    const instructions = [];\n    if (apiInstructions.length > 0) {\n      // Use API instructions if available\n      apiInstructions.forEach((instruction, index) => {\n        instructions.push(`${index + 1}. ${instruction.instruction} (${Math.round(instruction.distance)}m)`);\n      });\n    } else {\n      // Generate basic instructions from segments\n      segments.forEach((segment, index) => {\n        const direction = this.getDirection(segment.start, segment.end);\n        instructions.push(`${index + 1}. Walk ${direction} for ${Math.round(segment.distance)}m`);\n      });\n    }\n    return instructions;\n  }\n\n  // Get cardinal direction between two points\n  static getDirection(start, end) {\n    const latDiff = end.latitude - start.latitude;\n    const lngDiff = end.longitude - start.longitude;\n    const angle = Math.atan2(lngDiff, latDiff) * 180 / Math.PI;\n    if (angle >= -22.5 && angle < 22.5) return 'north';\n    if (angle >= 22.5 && angle < 67.5) return 'northeast';\n    if (angle >= 67.5 && angle < 112.5) return 'east';\n    if (angle >= 112.5 && angle < 157.5) return 'southeast';\n    if (angle >= 157.5 || angle < -157.5) return 'south';\n    if (angle >= -157.5 && angle < -112.5) return 'southwest';\n    if (angle >= -112.5 && angle < -67.5) return 'west';\n    if (angle >= -67.5 && angle < -22.5) return 'northwest';\n    return 'forward';\n  }\n\n  // Create fallback route when API fails\n  static createFallbackRoute(start, end, calmZones, stressZones) {\n    const distance = GPSService.calculateDistance(start, end);\n    const duration = distance / 1.4; // Average walking speed\n\n    // Simple straight-line route\n    const waypoints = [{\n      latitude: start.latitude,\n      longitude: start.longitude\n    }, {\n      latitude: end.latitude,\n      longitude: end.longitude\n    }];\n    const segments = [{\n      start: waypoints[0],\n      end: waypoints[1],\n      distance,\n      duration,\n      instructions: `Walk straight for ${Math.round(distance)}m`\n    }];\n    const {\n      calmScore,\n      avoidsStressZones,\n      includesCalmZones\n    } = this.analyzeRouteOptimization(waypoints, calmZones, stressZones);\n    return {\n      id: `route_${Date.now()}`,\n      start,\n      end,\n      waypoints,\n      segments,\n      totalDistance: distance,\n      totalDuration: duration,\n      calmScore,\n      avoidsStressZones,\n      includesCalmZones,\n      instructions: [`Walk straight for ${Math.round(distance)}m`]\n    };\n  }\n\n  // Get alternative routes (if API supports it)\n  static async getAlternativeRoutes(start, end, calmZones, stressZones) {\n    try {\n      // For now, return just the main route\n      // In a full implementation, you could request multiple alternatives\n      const mainRoute = await this.getWalkingRoute(start, end, calmZones, stressZones);\n      return [mainRoute];\n    } catch (error) {\n      console.error('Error getting alternative routes:', error);\n      return [];\n    }\n  }\n\n  // Check if a route is suitable for walking (sidewalks, pedestrian areas, etc.)\n  static isWalkableRoute(route) {\n    // Basic checks - in a real implementation, you'd check against road types, sidewalks, etc.\n    return route.totalDistance < 5000 &&\n    // Max 5km walk\n    route.segments.every(segment => segment.distance < 1000); // No single segment over 1km\n  }\n\n  // Get route difficulty level\n  static getRouteDifficulty(route) {\n    const distance = route.totalDistance;\n    const calmScore = route.calmScore;\n    if (distance < 1000 && calmScore > 0.7) return 'easy';\n    if (distance < 2500 && calmScore > 0.4) return 'moderate';\n    return 'challenging';\n  }\n}\nRoutingService.OPENROUTE_API_URL = 'https://api.openrouteservice.org/v2/directions';\nRoutingService.API_KEY = '5b3ce3597851110001cf6248a8b8b8b8a8b8b8b8';","map":{"version":3,"names":["GPSService","RoutingService","getWalkingRoute","start","end","calmZones","stressZones","basicRoute","getBasicRoute","optimizedRoute","optimizeRoute","error","console","createFallbackRoute","response","axios","get","OPENROUTE_API_URL","params","api_key","API_KEY","longitude","latitude","profile","format","instructions","geometry","data","warn","getGraphHopperRoute","_route$instructions","key","point","vehicle","points_encoded","route","paths","features","coordinates","points","properties","summary","distance","duration","time","map","inst","instruction","text","Error","waypoints","coord","segments","i","length","calculateDistance","timestamp","push","calmScore","avoidsStressZones","includesCalmZones","analyzeRouteOptimization","generateInstructions","id","Date","now","totalDistance","totalDuration","forEach","pointLocation","zone","isWithinRadius","center","radius","includes","Math","max","min","apiInstructions","index","round","segment","direction","getDirection","latDiff","lngDiff","angle","atan2","PI","getAlternativeRoutes","mainRoute","isWalkableRoute","every","getRouteDifficulty"],"sources":["C:/Users/usman/.cursor/alzense/src/services/routing.ts"],"sourcesContent":["import { Location, CalmZone, StressZone } from '../types';\r\nimport { GPSService } from './gps';\r\n\r\nexport interface RoutePoint {\r\n  latitude: number;\r\n  longitude: number;\r\n}\r\n\r\nexport interface RouteSegment {\r\n  start: RoutePoint;\r\n  end: RoutePoint;\r\n  distance: number; // in meters\r\n  duration: number; // in seconds\r\n  instructions?: string;\r\n}\r\n\r\nexport interface OptimizedRoute {\r\n  id: string;\r\n  start: Location;\r\n  end: Location;\r\n  waypoints: RoutePoint[];\r\n  segments: RouteSegment[];\r\n  totalDistance: number; // in meters\r\n  totalDuration: number; // in seconds\r\n  calmScore: number; // 0-1, higher is calmer\r\n  avoidsStressZones: string[];\r\n  includesCalmZones: string[];\r\n  instructions: string[];\r\n}\r\n\r\nexport class RoutingService {\r\n  private static readonly OPENROUTE_API_URL = 'https://api.openrouteservice.org/v2/directions';\r\n  private static readonly API_KEY = '5b3ce3597851110001cf6248a8b8b8b8a8b8b8b8'; // Free tier key - replace with your own\r\n\r\n  // Get a real walking route between two points\r\n  static async getWalkingRoute(\r\n    start: Location,\r\n    end: Location,\r\n    calmZones: CalmZone[],\r\n    stressZones: StressZone[]\r\n  ): Promise<OptimizedRoute> {\r\n    try {\r\n      // First, get the basic route from OpenRouteService\r\n      const basicRoute = await this.getBasicRoute(start, end);\r\n      \r\n      // Then optimize it based on calm/stress zones\r\n      const optimizedRoute = await this.optimizeRoute(basicRoute, calmZones, stressZones);\r\n      \r\n      return optimizedRoute;\r\n    } catch (error) {\r\n      console.error('Routing error:', error);\r\n      // Fallback to simple straight-line route\r\n      return this.createFallbackRoute(start, end, calmZones, stressZones);\r\n    }\r\n  }\r\n\r\n  // Get basic route from OpenRouteService\r\n  private static async getBasicRoute(start: Location, end: Location): Promise<any> {\r\n    try {\r\n      const response = await axios.get(this.OPENROUTE_API_URL, {\r\n        params: {\r\n          api_key: this.API_KEY,\r\n          start: `${start.longitude},${start.latitude}`,\r\n          end: `${end.longitude},${end.latitude}`,\r\n          profile: 'foot-walking',\r\n          format: 'json',\r\n          instructions: true,\r\n          geometry: true\r\n        }\r\n      });\r\n\r\n      return response.data;\r\n    } catch (error) {\r\n      console.warn('OpenRouteService failed, trying GraphHopper...', error);\r\n      return await this.getGraphHopperRoute(start, end);\r\n    }\r\n  }\r\n\r\n  // Fallback to GraphHopper (free tier)\r\n  private static async getGraphHopperRoute(start: Location, end: Location): Promise<any> {\r\n    try {\r\n      const response = await axios.get('https://graphhopper.com/api/1/route', {\r\n        params: {\r\n          key: 'demo', // Free demo key\r\n          point: [`${start.latitude},${start.longitude}`, `${end.latitude},${end.longitude}`],\r\n          vehicle: 'foot',\r\n          instructions: true,\r\n          points_encoded: false\r\n        }\r\n      });\r\n\r\n      // Convert GraphHopper format to our expected format\r\n      const route = response.data.paths[0];\r\n      return {\r\n        features: [{\r\n          geometry: {\r\n            coordinates: route.points.coordinates\r\n          },\r\n          properties: {\r\n            summary: {\r\n              distance: route.distance,\r\n              duration: route.time / 1000 // Convert ms to seconds\r\n            },\r\n            instructions: route.instructions?.map((inst: any) => ({\r\n              instruction: inst.text,\r\n              distance: inst.distance\r\n            })) || []\r\n          }\r\n        }]\r\n      };\r\n    } catch (error) {\r\n      console.warn('GraphHopper also failed, using fallback route', error);\r\n      throw new Error('All routing services failed');\r\n    }\r\n  }\r\n\r\n  // Optimize route based on calm/stress zones\r\n  private static async optimizeRoute(\r\n    basicRoute: any,\r\n    calmZones: CalmZone[],\r\n    stressZones: StressZone[]\r\n  ): Promise<OptimizedRoute> {\r\n    const route = basicRoute.features[0];\r\n    const geometry = route.geometry.coordinates;\r\n    const properties = route.properties;\r\n    \r\n    // Convert coordinates to our format\r\n    const waypoints: RoutePoint[] = geometry.map((coord: number[]) => ({\r\n      longitude: coord[0],\r\n      latitude: coord[1]\r\n    }));\r\n\r\n    // Create route segments\r\n    const segments: RouteSegment[] = [];\r\n    for (let i = 0; i < waypoints.length - 1; i++) {\r\n      const start = waypoints[i];\r\n      const end = waypoints[i + 1];\r\n      const distance = GPSService.calculateDistance(\r\n        { latitude: start.latitude, longitude: start.longitude, timestamp: 0 },\r\n        { latitude: end.latitude, longitude: end.longitude, timestamp: 0 }\r\n      );\r\n      \r\n      segments.push({\r\n        start,\r\n        end,\r\n        distance,\r\n        duration: distance / 1.4 // Average walking speed: 1.4 m/s\r\n      });\r\n    }\r\n\r\n    // Calculate calm score and zone interactions\r\n    const { calmScore, avoidsStressZones, includesCalmZones } = this.analyzeRouteOptimization(\r\n      waypoints,\r\n      calmZones,\r\n      stressZones\r\n    );\r\n\r\n    // Generate instructions\r\n    const instructions = this.generateInstructions(segments, properties.instructions || []);\r\n\r\n    return {\r\n      id: `route_${Date.now()}`,\r\n      start: { latitude: waypoints[0].latitude, longitude: waypoints[0].longitude, timestamp: 0 },\r\n      end: { latitude: waypoints[waypoints.length - 1].latitude, longitude: waypoints[waypoints.length - 1].longitude, timestamp: 0 },\r\n      waypoints,\r\n      segments,\r\n      totalDistance: properties.summary.distance,\r\n      totalDuration: properties.summary.duration,\r\n      calmScore,\r\n      avoidsStressZones,\r\n      includesCalmZones,\r\n      instructions\r\n    };\r\n  }\r\n\r\n  // Analyze route optimization based on calm/stress zones\r\n  private static analyzeRouteOptimization(\r\n    waypoints: RoutePoint[],\r\n    calmZones: CalmZone[],\r\n    stressZones: StressZone[]\r\n  ): { calmScore: number; avoidsStressZones: string[]; includesCalmZones: string[] } {\r\n    let calmScore = 0.5; // Base score\r\n    const avoidsStressZones: string[] = [];\r\n    const includesCalmZones: string[] = [];\r\n\r\n    // Check each waypoint against zones\r\n    waypoints.forEach(point => {\r\n      const pointLocation = { latitude: point.latitude, longitude: point.longitude, timestamp: 0 };\r\n      \r\n      // Check stress zones\r\n      stressZones.forEach(zone => {\r\n        if (GPSService.isWithinRadius(zone.center, pointLocation, zone.radius)) {\r\n          calmScore -= 0.1; // Penalize for going through stress zones\r\n          if (!avoidsStressZones.includes(zone.id)) {\r\n            avoidsStressZones.push(zone.id);\r\n          }\r\n        }\r\n      });\r\n\r\n      // Check calm zones\r\n      calmZones.forEach(zone => {\r\n        if (GPSService.isWithinRadius(zone.center, pointLocation, zone.radius)) {\r\n          calmScore += 0.05; // Reward for going through calm zones\r\n          if (!includesCalmZones.includes(zone.id)) {\r\n            includesCalmZones.push(zone.id);\r\n          }\r\n        }\r\n      });\r\n    });\r\n\r\n    // Normalize calm score to 0-1 range\r\n    calmScore = Math.max(0, Math.min(1, calmScore));\r\n\r\n    return { calmScore, avoidsStressZones, includesCalmZones };\r\n  }\r\n\r\n  // Generate human-readable instructions\r\n  private static generateInstructions(segments: RouteSegment[], apiInstructions: any[]): string[] {\r\n    const instructions: string[] = [];\r\n    \r\n    if (apiInstructions.length > 0) {\r\n      // Use API instructions if available\r\n      apiInstructions.forEach((instruction, index) => {\r\n        instructions.push(`${index + 1}. ${instruction.instruction} (${Math.round(instruction.distance)}m)`);\r\n      });\r\n    } else {\r\n      // Generate basic instructions from segments\r\n      segments.forEach((segment, index) => {\r\n        const direction = this.getDirection(segment.start, segment.end);\r\n        instructions.push(`${index + 1}. Walk ${direction} for ${Math.round(segment.distance)}m`);\r\n      });\r\n    }\r\n\r\n    return instructions;\r\n  }\r\n\r\n  // Get cardinal direction between two points\r\n  private static getDirection(start: RoutePoint, end: RoutePoint): string {\r\n    const latDiff = end.latitude - start.latitude;\r\n    const lngDiff = end.longitude - start.longitude;\r\n    const angle = Math.atan2(lngDiff, latDiff) * 180 / Math.PI;\r\n    \r\n    if (angle >= -22.5 && angle < 22.5) return 'north';\r\n    if (angle >= 22.5 && angle < 67.5) return 'northeast';\r\n    if (angle >= 67.5 && angle < 112.5) return 'east';\r\n    if (angle >= 112.5 && angle < 157.5) return 'southeast';\r\n    if (angle >= 157.5 || angle < -157.5) return 'south';\r\n    if (angle >= -157.5 && angle < -112.5) return 'southwest';\r\n    if (angle >= -112.5 && angle < -67.5) return 'west';\r\n    if (angle >= -67.5 && angle < -22.5) return 'northwest';\r\n    \r\n    return 'forward';\r\n  }\r\n\r\n  // Create fallback route when API fails\r\n  private static createFallbackRoute(\r\n    start: Location,\r\n    end: Location,\r\n    calmZones: CalmZone[],\r\n    stressZones: StressZone[]\r\n  ): OptimizedRoute {\r\n    const distance = GPSService.calculateDistance(start, end);\r\n    const duration = distance / 1.4; // Average walking speed\r\n    \r\n    // Simple straight-line route\r\n    const waypoints: RoutePoint[] = [\r\n      { latitude: start.latitude, longitude: start.longitude },\r\n      { latitude: end.latitude, longitude: end.longitude }\r\n    ];\r\n\r\n    const segments: RouteSegment[] = [{\r\n      start: waypoints[0],\r\n      end: waypoints[1],\r\n      distance,\r\n      duration,\r\n      instructions: `Walk straight for ${Math.round(distance)}m`\r\n    }];\r\n\r\n    const { calmScore, avoidsStressZones, includesCalmZones } = this.analyzeRouteOptimization(\r\n      waypoints,\r\n      calmZones,\r\n      stressZones\r\n    );\r\n\r\n    return {\r\n      id: `route_${Date.now()}`,\r\n      start,\r\n      end,\r\n      waypoints,\r\n      segments,\r\n      totalDistance: distance,\r\n      totalDuration: duration,\r\n      calmScore,\r\n      avoidsStressZones,\r\n      includesCalmZones,\r\n      instructions: [`Walk straight for ${Math.round(distance)}m`]\r\n    };\r\n  }\r\n\r\n  // Get alternative routes (if API supports it)\r\n  static async getAlternativeRoutes(\r\n    start: Location,\r\n    end: Location,\r\n    calmZones: CalmZone[],\r\n    stressZones: StressZone[]\r\n  ): Promise<OptimizedRoute[]> {\r\n    try {\r\n      // For now, return just the main route\r\n      // In a full implementation, you could request multiple alternatives\r\n      const mainRoute = await this.getWalkingRoute(start, end, calmZones, stressZones);\r\n      return [mainRoute];\r\n    } catch (error) {\r\n      console.error('Error getting alternative routes:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  // Check if a route is suitable for walking (sidewalks, pedestrian areas, etc.)\r\n  static isWalkableRoute(route: OptimizedRoute): boolean {\r\n    // Basic checks - in a real implementation, you'd check against road types, sidewalks, etc.\r\n    return route.totalDistance < 5000 && // Max 5km walk\r\n           route.segments.every(segment => segment.distance < 1000); // No single segment over 1km\r\n  }\r\n\r\n  // Get route difficulty level\r\n  static getRouteDifficulty(route: OptimizedRoute): 'easy' | 'moderate' | 'challenging' {\r\n    const distance = route.totalDistance;\r\n    const calmScore = route.calmScore;\r\n    \r\n    if (distance < 1000 && calmScore > 0.7) return 'easy';\r\n    if (distance < 2500 && calmScore > 0.4) return 'moderate';\r\n    return 'challenging';\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}