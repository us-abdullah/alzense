{"ast":null,"code":"import { GPSService } from './gps';\nexport class RoutingService {\n  // Free tier key - replace with your own\n\n  // Get a real walking route between two points\n  static async getWalkingRoute(start, end, calmZones, stressZones) {\n    try {\n      // First, get the basic route from OpenRouteService\n      const basicRoute = await this.getBasicRoute(start, end);\n\n      // Then optimize it based on calm/stress zones\n      const optimizedRoute = await this.optimizeRoute(basicRoute, calmZones, stressZones);\n      return optimizedRoute;\n    } catch (error) {\n      console.error('Routing error:', error);\n      // Fallback to simple straight-line route\n      return this.createFallbackRoute(start, end, calmZones, stressZones);\n    }\n  }\n\n  // Get basic route from OpenRouteService\n  static async getBasicRoute(start, end) {\n    try {\n      const params = new URLSearchParams({\n        api_key: this.API_KEY,\n        start: `${start.longitude},${start.latitude}`,\n        end: `${end.longitude},${end.latitude}`,\n        profile: 'foot-walking',\n        format: 'json',\n        instructions: 'true',\n        geometry: 'true'\n      });\n      const response = await fetch(`${this.OPENROUTE_API_URL}?${params}`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      return data;\n    } catch (error) {\n      console.warn('OpenRouteService failed, trying GraphHopper...', error);\n      return await this.getGraphHopperRoute(start, end);\n    }\n  }\n\n  // Fallback to GraphHopper (free tier)\n  static async getGraphHopperRoute(start, end) {\n    try {\n      var _route$instructions;\n      const params = new URLSearchParams({\n        key: 'demo',\n        // Free demo key\n        point: [`${start.latitude},${start.longitude}`, `${end.latitude},${end.longitude}`],\n        vehicle: 'foot',\n        instructions: 'true',\n        points_encoded: 'false'\n      });\n      const response = await fetch(`https://graphhopper.com/api/1/route?${params}`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n\n      // Convert GraphHopper format to our expected format\n      const route = data.paths[0];\n      return {\n        features: [{\n          geometry: {\n            coordinates: route.points.coordinates\n          },\n          properties: {\n            summary: {\n              distance: route.distance,\n              duration: route.time / 1000 // Convert ms to seconds\n            },\n            instructions: ((_route$instructions = route.instructions) === null || _route$instructions === void 0 ? void 0 : _route$instructions.map(inst => ({\n              instruction: inst.text,\n              distance: inst.distance\n            }))) || []\n          }\n        }]\n      };\n    } catch (error) {\n      console.warn('GraphHopper also failed, using fallback route', error);\n      throw new Error('All routing services failed');\n    }\n  }\n\n  // Optimize route based on calm/stress zones\n  static async optimizeRoute(basicRoute, calmZones, stressZones) {\n    const route = basicRoute.features[0];\n    const geometry = route.geometry.coordinates;\n    const properties = route.properties;\n\n    // Convert coordinates to our format\n    const waypoints = geometry.map(coord => ({\n      longitude: coord[0],\n      latitude: coord[1]\n    }));\n\n    // Create route segments\n    const segments = [];\n    for (let i = 0; i < waypoints.length - 1; i++) {\n      const start = waypoints[i];\n      const end = waypoints[i + 1];\n      const distance = GPSService.calculateDistance({\n        latitude: start.latitude,\n        longitude: start.longitude,\n        timestamp: 0\n      }, {\n        latitude: end.latitude,\n        longitude: end.longitude,\n        timestamp: 0\n      });\n      segments.push({\n        start,\n        end,\n        distance,\n        duration: distance / 1.4 // Average walking speed: 1.4 m/s\n      });\n    }\n\n    // Calculate calm score and zone interactions\n    const {\n      calmScore,\n      avoidsStressZones,\n      includesCalmZones\n    } = this.analyzeRouteOptimization(waypoints, calmZones, stressZones);\n\n    // Generate instructions\n    const instructions = this.generateInstructions(segments, properties.instructions || []);\n    return {\n      id: `route_${Date.now()}`,\n      start: {\n        latitude: waypoints[0].latitude,\n        longitude: waypoints[0].longitude,\n        timestamp: 0\n      },\n      end: {\n        latitude: waypoints[waypoints.length - 1].latitude,\n        longitude: waypoints[waypoints.length - 1].longitude,\n        timestamp: 0\n      },\n      waypoints,\n      segments,\n      totalDistance: properties.summary.distance,\n      totalDuration: properties.summary.duration,\n      calmScore,\n      avoidsStressZones,\n      includesCalmZones,\n      instructions\n    };\n  }\n\n  // Analyze route optimization based on calm/stress zones\n  static analyzeRouteOptimization(waypoints, calmZones, stressZones) {\n    let calmScore = 0.5; // Base score\n    const avoidsStressZones = [];\n    const includesCalmZones = [];\n\n    // Check each waypoint against zones\n    waypoints.forEach(point => {\n      const pointLocation = {\n        latitude: point.latitude,\n        longitude: point.longitude,\n        timestamp: 0\n      };\n\n      // Check stress zones\n      stressZones.forEach(zone => {\n        if (GPSService.isWithinRadius(zone.center, pointLocation, zone.radius)) {\n          calmScore -= 0.1; // Penalize for going through stress zones\n          if (!avoidsStressZones.includes(zone.id)) {\n            avoidsStressZones.push(zone.id);\n          }\n        }\n      });\n\n      // Check calm zones\n      calmZones.forEach(zone => {\n        if (GPSService.isWithinRadius(zone.center, pointLocation, zone.radius)) {\n          calmScore += 0.05; // Reward for going through calm zones\n          if (!includesCalmZones.includes(zone.id)) {\n            includesCalmZones.push(zone.id);\n          }\n        }\n      });\n    });\n\n    // Normalize calm score to 0-1 range\n    calmScore = Math.max(0, Math.min(1, calmScore));\n    return {\n      calmScore,\n      avoidsStressZones,\n      includesCalmZones\n    };\n  }\n\n  // Generate human-readable instructions\n  static generateInstructions(segments, apiInstructions) {\n    const instructions = [];\n    if (apiInstructions.length > 0) {\n      // Use API instructions if available\n      apiInstructions.forEach((instruction, index) => {\n        instructions.push(`${index + 1}. ${instruction.instruction} (${Math.round(instruction.distance)}m)`);\n      });\n    } else {\n      // Generate basic instructions from segments\n      segments.forEach((segment, index) => {\n        const direction = this.getDirection(segment.start, segment.end);\n        instructions.push(`${index + 1}. Walk ${direction} for ${Math.round(segment.distance)}m`);\n      });\n    }\n    return instructions;\n  }\n\n  // Get cardinal direction between two points\n  static getDirection(start, end) {\n    const latDiff = end.latitude - start.latitude;\n    const lngDiff = end.longitude - start.longitude;\n    const angle = Math.atan2(lngDiff, latDiff) * 180 / Math.PI;\n    if (angle >= -22.5 && angle < 22.5) return 'north';\n    if (angle >= 22.5 && angle < 67.5) return 'northeast';\n    if (angle >= 67.5 && angle < 112.5) return 'east';\n    if (angle >= 112.5 && angle < 157.5) return 'southeast';\n    if (angle >= 157.5 || angle < -157.5) return 'south';\n    if (angle >= -157.5 && angle < -112.5) return 'southwest';\n    if (angle >= -112.5 && angle < -67.5) return 'west';\n    if (angle >= -67.5 && angle < -22.5) return 'northwest';\n    return 'forward';\n  }\n\n  // Create fallback route when API fails\n  static createFallbackRoute(start, end, calmZones, stressZones) {\n    const distance = GPSService.calculateDistance(start, end);\n    const duration = distance / 1.4; // Average walking speed\n\n    // Simple straight-line route\n    const waypoints = [{\n      latitude: start.latitude,\n      longitude: start.longitude\n    }, {\n      latitude: end.latitude,\n      longitude: end.longitude\n    }];\n    const segments = [{\n      start: waypoints[0],\n      end: waypoints[1],\n      distance,\n      duration,\n      instructions: `Walk straight for ${Math.round(distance)}m`\n    }];\n    const {\n      calmScore,\n      avoidsStressZones,\n      includesCalmZones\n    } = this.analyzeRouteOptimization(waypoints, calmZones, stressZones);\n    return {\n      id: `route_${Date.now()}`,\n      start,\n      end,\n      waypoints,\n      segments,\n      totalDistance: distance,\n      totalDuration: duration,\n      calmScore,\n      avoidsStressZones,\n      includesCalmZones,\n      instructions: [`Walk straight for ${Math.round(distance)}m`]\n    };\n  }\n\n  // Get alternative routes (if API supports it)\n  static async getAlternativeRoutes(start, end, calmZones, stressZones) {\n    try {\n      // For now, return just the main route\n      // In a full implementation, you could request multiple alternatives\n      const mainRoute = await this.getWalkingRoute(start, end, calmZones, stressZones);\n      return [mainRoute];\n    } catch (error) {\n      console.error('Error getting alternative routes:', error);\n      return [];\n    }\n  }\n\n  // Check if a route is suitable for walking (sidewalks, pedestrian areas, etc.)\n  static isWalkableRoute(route) {\n    // Basic checks - in a real implementation, you'd check against road types, sidewalks, etc.\n    return route.totalDistance < 5000 &&\n    // Max 5km walk\n    route.segments.every(segment => segment.distance < 1000); // No single segment over 1km\n  }\n\n  // Get route difficulty level\n  static getRouteDifficulty(route) {\n    const distance = route.totalDistance;\n    const calmScore = route.calmScore;\n    if (distance < 1000 && calmScore > 0.7) return 'easy';\n    if (distance < 2500 && calmScore > 0.4) return 'moderate';\n    return 'challenging';\n  }\n}\nRoutingService.OPENROUTE_API_URL = 'https://api.openrouteservice.org/v2/directions';\nRoutingService.API_KEY = '5b3ce3597851110001cf6248a8b8b8b8a8b8b8b8';","map":{"version":3,"names":["GPSService","RoutingService","getWalkingRoute","start","end","calmZones","stressZones","basicRoute","getBasicRoute","optimizedRoute","optimizeRoute","error","console","createFallbackRoute","params","URLSearchParams","api_key","API_KEY","longitude","latitude","profile","format","instructions","geometry","response","fetch","OPENROUTE_API_URL","ok","Error","status","data","json","warn","getGraphHopperRoute","_route$instructions","key","point","vehicle","points_encoded","route","paths","features","coordinates","points","properties","summary","distance","duration","time","map","inst","instruction","text","waypoints","coord","segments","i","length","calculateDistance","timestamp","push","calmScore","avoidsStressZones","includesCalmZones","analyzeRouteOptimization","generateInstructions","id","Date","now","totalDistance","totalDuration","forEach","pointLocation","zone","isWithinRadius","center","radius","includes","Math","max","min","apiInstructions","index","round","segment","direction","getDirection","latDiff","lngDiff","angle","atan2","PI","getAlternativeRoutes","mainRoute","isWalkableRoute","every","getRouteDifficulty"],"sources":["C:/Users/usman/.cursor/alzense/src/services/routing.ts"],"sourcesContent":["import { Location, CalmZone, StressZone } from '../types';\r\nimport { GPSService } from './gps';\r\n\r\nexport interface RoutePoint {\r\n  latitude: number;\r\n  longitude: number;\r\n}\r\n\r\nexport interface RouteSegment {\r\n  start: RoutePoint;\r\n  end: RoutePoint;\r\n  distance: number; // in meters\r\n  duration: number; // in seconds\r\n  instructions?: string;\r\n}\r\n\r\nexport interface OptimizedRoute {\r\n  id: string;\r\n  start: Location;\r\n  end: Location;\r\n  waypoints: RoutePoint[];\r\n  segments: RouteSegment[];\r\n  totalDistance: number; // in meters\r\n  totalDuration: number; // in seconds\r\n  calmScore: number; // 0-1, higher is calmer\r\n  avoidsStressZones: string[];\r\n  includesCalmZones: string[];\r\n  instructions: string[];\r\n}\r\n\r\nexport class RoutingService {\r\n  private static readonly OPENROUTE_API_URL = 'https://api.openrouteservice.org/v2/directions';\r\n  private static readonly API_KEY = '5b3ce3597851110001cf6248a8b8b8b8a8b8b8b8'; // Free tier key - replace with your own\r\n\r\n  // Get a real walking route between two points\r\n  static async getWalkingRoute(\r\n    start: Location,\r\n    end: Location,\r\n    calmZones: CalmZone[],\r\n    stressZones: StressZone[]\r\n  ): Promise<OptimizedRoute> {\r\n    try {\r\n      // First, get the basic route from OpenRouteService\r\n      const basicRoute = await this.getBasicRoute(start, end);\r\n      \r\n      // Then optimize it based on calm/stress zones\r\n      const optimizedRoute = await this.optimizeRoute(basicRoute, calmZones, stressZones);\r\n      \r\n      return optimizedRoute;\r\n    } catch (error) {\r\n      console.error('Routing error:', error);\r\n      // Fallback to simple straight-line route\r\n      return this.createFallbackRoute(start, end, calmZones, stressZones);\r\n    }\r\n  }\r\n\r\n  // Get basic route from OpenRouteService\r\n  private static async getBasicRoute(start: Location, end: Location): Promise<any> {\r\n    try {\r\n      const params = new URLSearchParams({\r\n        api_key: this.API_KEY,\r\n        start: `${start.longitude},${start.latitude}`,\r\n        end: `${end.longitude},${end.latitude}`,\r\n        profile: 'foot-walking',\r\n        format: 'json',\r\n        instructions: 'true',\r\n        geometry: 'true'\r\n      });\r\n\r\n      const response = await fetch(`${this.OPENROUTE_API_URL}?${params}`);\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n      \r\n      const data = await response.json();\r\n      return data;\r\n    } catch (error) {\r\n      console.warn('OpenRouteService failed, trying GraphHopper...', error);\r\n      return await this.getGraphHopperRoute(start, end);\r\n    }\r\n  }\r\n\r\n  // Fallback to GraphHopper (free tier)\r\n  private static async getGraphHopperRoute(start: Location, end: Location): Promise<any> {\r\n    try {\r\n      const params = new URLSearchParams({\r\n        key: 'demo', // Free demo key\r\n        point: [`${start.latitude},${start.longitude}`, `${end.latitude},${end.longitude}`],\r\n        vehicle: 'foot',\r\n        instructions: 'true',\r\n        points_encoded: 'false'\r\n      });\r\n\r\n      const response = await fetch(`https://graphhopper.com/api/1/route?${params}`);\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n      \r\n      const data = await response.json();\r\n\r\n      // Convert GraphHopper format to our expected format\r\n      const route = data.paths[0];\r\n      return {\r\n        features: [{\r\n          geometry: {\r\n            coordinates: route.points.coordinates\r\n          },\r\n          properties: {\r\n            summary: {\r\n              distance: route.distance,\r\n              duration: route.time / 1000 // Convert ms to seconds\r\n            },\r\n            instructions: route.instructions?.map((inst: any) => ({\r\n              instruction: inst.text,\r\n              distance: inst.distance\r\n            })) || []\r\n          }\r\n        }]\r\n      };\r\n    } catch (error) {\r\n      console.warn('GraphHopper also failed, using fallback route', error);\r\n      throw new Error('All routing services failed');\r\n    }\r\n  }\r\n\r\n  // Optimize route based on calm/stress zones\r\n  private static async optimizeRoute(\r\n    basicRoute: any,\r\n    calmZones: CalmZone[],\r\n    stressZones: StressZone[]\r\n  ): Promise<OptimizedRoute> {\r\n    const route = basicRoute.features[0];\r\n    const geometry = route.geometry.coordinates;\r\n    const properties = route.properties;\r\n    \r\n    // Convert coordinates to our format\r\n    const waypoints: RoutePoint[] = geometry.map((coord: number[]) => ({\r\n      longitude: coord[0],\r\n      latitude: coord[1]\r\n    }));\r\n\r\n    // Create route segments\r\n    const segments: RouteSegment[] = [];\r\n    for (let i = 0; i < waypoints.length - 1; i++) {\r\n      const start = waypoints[i];\r\n      const end = waypoints[i + 1];\r\n      const distance = GPSService.calculateDistance(\r\n        { latitude: start.latitude, longitude: start.longitude, timestamp: 0 },\r\n        { latitude: end.latitude, longitude: end.longitude, timestamp: 0 }\r\n      );\r\n      \r\n      segments.push({\r\n        start,\r\n        end,\r\n        distance,\r\n        duration: distance / 1.4 // Average walking speed: 1.4 m/s\r\n      });\r\n    }\r\n\r\n    // Calculate calm score and zone interactions\r\n    const { calmScore, avoidsStressZones, includesCalmZones } = this.analyzeRouteOptimization(\r\n      waypoints,\r\n      calmZones,\r\n      stressZones\r\n    );\r\n\r\n    // Generate instructions\r\n    const instructions = this.generateInstructions(segments, properties.instructions || []);\r\n\r\n    return {\r\n      id: `route_${Date.now()}`,\r\n      start: { latitude: waypoints[0].latitude, longitude: waypoints[0].longitude, timestamp: 0 },\r\n      end: { latitude: waypoints[waypoints.length - 1].latitude, longitude: waypoints[waypoints.length - 1].longitude, timestamp: 0 },\r\n      waypoints,\r\n      segments,\r\n      totalDistance: properties.summary.distance,\r\n      totalDuration: properties.summary.duration,\r\n      calmScore,\r\n      avoidsStressZones,\r\n      includesCalmZones,\r\n      instructions\r\n    };\r\n  }\r\n\r\n  // Analyze route optimization based on calm/stress zones\r\n  private static analyzeRouteOptimization(\r\n    waypoints: RoutePoint[],\r\n    calmZones: CalmZone[],\r\n    stressZones: StressZone[]\r\n  ): { calmScore: number; avoidsStressZones: string[]; includesCalmZones: string[] } {\r\n    let calmScore = 0.5; // Base score\r\n    const avoidsStressZones: string[] = [];\r\n    const includesCalmZones: string[] = [];\r\n\r\n    // Check each waypoint against zones\r\n    waypoints.forEach(point => {\r\n      const pointLocation = { latitude: point.latitude, longitude: point.longitude, timestamp: 0 };\r\n      \r\n      // Check stress zones\r\n      stressZones.forEach(zone => {\r\n        if (GPSService.isWithinRadius(zone.center, pointLocation, zone.radius)) {\r\n          calmScore -= 0.1; // Penalize for going through stress zones\r\n          if (!avoidsStressZones.includes(zone.id)) {\r\n            avoidsStressZones.push(zone.id);\r\n          }\r\n        }\r\n      });\r\n\r\n      // Check calm zones\r\n      calmZones.forEach(zone => {\r\n        if (GPSService.isWithinRadius(zone.center, pointLocation, zone.radius)) {\r\n          calmScore += 0.05; // Reward for going through calm zones\r\n          if (!includesCalmZones.includes(zone.id)) {\r\n            includesCalmZones.push(zone.id);\r\n          }\r\n        }\r\n      });\r\n    });\r\n\r\n    // Normalize calm score to 0-1 range\r\n    calmScore = Math.max(0, Math.min(1, calmScore));\r\n\r\n    return { calmScore, avoidsStressZones, includesCalmZones };\r\n  }\r\n\r\n  // Generate human-readable instructions\r\n  private static generateInstructions(segments: RouteSegment[], apiInstructions: any[]): string[] {\r\n    const instructions: string[] = [];\r\n    \r\n    if (apiInstructions.length > 0) {\r\n      // Use API instructions if available\r\n      apiInstructions.forEach((instruction, index) => {\r\n        instructions.push(`${index + 1}. ${instruction.instruction} (${Math.round(instruction.distance)}m)`);\r\n      });\r\n    } else {\r\n      // Generate basic instructions from segments\r\n      segments.forEach((segment, index) => {\r\n        const direction = this.getDirection(segment.start, segment.end);\r\n        instructions.push(`${index + 1}. Walk ${direction} for ${Math.round(segment.distance)}m`);\r\n      });\r\n    }\r\n\r\n    return instructions;\r\n  }\r\n\r\n  // Get cardinal direction between two points\r\n  private static getDirection(start: RoutePoint, end: RoutePoint): string {\r\n    const latDiff = end.latitude - start.latitude;\r\n    const lngDiff = end.longitude - start.longitude;\r\n    const angle = Math.atan2(lngDiff, latDiff) * 180 / Math.PI;\r\n    \r\n    if (angle >= -22.5 && angle < 22.5) return 'north';\r\n    if (angle >= 22.5 && angle < 67.5) return 'northeast';\r\n    if (angle >= 67.5 && angle < 112.5) return 'east';\r\n    if (angle >= 112.5 && angle < 157.5) return 'southeast';\r\n    if (angle >= 157.5 || angle < -157.5) return 'south';\r\n    if (angle >= -157.5 && angle < -112.5) return 'southwest';\r\n    if (angle >= -112.5 && angle < -67.5) return 'west';\r\n    if (angle >= -67.5 && angle < -22.5) return 'northwest';\r\n    \r\n    return 'forward';\r\n  }\r\n\r\n  // Create fallback route when API fails\r\n  private static createFallbackRoute(\r\n    start: Location,\r\n    end: Location,\r\n    calmZones: CalmZone[],\r\n    stressZones: StressZone[]\r\n  ): OptimizedRoute {\r\n    const distance = GPSService.calculateDistance(start, end);\r\n    const duration = distance / 1.4; // Average walking speed\r\n    \r\n    // Simple straight-line route\r\n    const waypoints: RoutePoint[] = [\r\n      { latitude: start.latitude, longitude: start.longitude },\r\n      { latitude: end.latitude, longitude: end.longitude }\r\n    ];\r\n\r\n    const segments: RouteSegment[] = [{\r\n      start: waypoints[0],\r\n      end: waypoints[1],\r\n      distance,\r\n      duration,\r\n      instructions: `Walk straight for ${Math.round(distance)}m`\r\n    }];\r\n\r\n    const { calmScore, avoidsStressZones, includesCalmZones } = this.analyzeRouteOptimization(\r\n      waypoints,\r\n      calmZones,\r\n      stressZones\r\n    );\r\n\r\n    return {\r\n      id: `route_${Date.now()}`,\r\n      start,\r\n      end,\r\n      waypoints,\r\n      segments,\r\n      totalDistance: distance,\r\n      totalDuration: duration,\r\n      calmScore,\r\n      avoidsStressZones,\r\n      includesCalmZones,\r\n      instructions: [`Walk straight for ${Math.round(distance)}m`]\r\n    };\r\n  }\r\n\r\n  // Get alternative routes (if API supports it)\r\n  static async getAlternativeRoutes(\r\n    start: Location,\r\n    end: Location,\r\n    calmZones: CalmZone[],\r\n    stressZones: StressZone[]\r\n  ): Promise<OptimizedRoute[]> {\r\n    try {\r\n      // For now, return just the main route\r\n      // In a full implementation, you could request multiple alternatives\r\n      const mainRoute = await this.getWalkingRoute(start, end, calmZones, stressZones);\r\n      return [mainRoute];\r\n    } catch (error) {\r\n      console.error('Error getting alternative routes:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  // Check if a route is suitable for walking (sidewalks, pedestrian areas, etc.)\r\n  static isWalkableRoute(route: OptimizedRoute): boolean {\r\n    // Basic checks - in a real implementation, you'd check against road types, sidewalks, etc.\r\n    return route.totalDistance < 5000 && // Max 5km walk\r\n           route.segments.every(segment => segment.distance < 1000); // No single segment over 1km\r\n  }\r\n\r\n  // Get route difficulty level\r\n  static getRouteDifficulty(route: OptimizedRoute): 'easy' | 'moderate' | 'challenging' {\r\n    const distance = route.totalDistance;\r\n    const calmScore = route.calmScore;\r\n    \r\n    if (distance < 1000 && calmScore > 0.7) return 'easy';\r\n    if (distance < 2500 && calmScore > 0.4) return 'moderate';\r\n    return 'challenging';\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}