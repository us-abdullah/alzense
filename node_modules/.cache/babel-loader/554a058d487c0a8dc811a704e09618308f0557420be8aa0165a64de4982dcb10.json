{"ast":null,"code":"export class GPSService{constructor(onLocationUpdate,onError){this.watchId=null;this.onLocationUpdate=null;this.onError=null;this.onLocationUpdate=onLocationUpdate;this.onError=onError;}async startTracking(){if(!navigator.geolocation){var _this$onError;(_this$onError=this.onError)===null||_this$onError===void 0?void 0:_this$onError.call(this,new GeolocationPositionError());return false;}try{// First, get current position\nconst position=await this.getCurrentPosition();if(position){var _this$onLocationUpdat;(_this$onLocationUpdat=this.onLocationUpdate)===null||_this$onLocationUpdat===void 0?void 0:_this$onLocationUpdat.call(this,this.positionToLocation(position));}// Then start watching for updates\nthis.watchId=navigator.geolocation.watchPosition(position=>{var _this$onLocationUpdat2;(_this$onLocationUpdat2=this.onLocationUpdate)===null||_this$onLocationUpdat2===void 0?void 0:_this$onLocationUpdat2.call(this,this.positionToLocation(position));},error=>{var _this$onError2;console.error('GPS error:',error);(_this$onError2=this.onError)===null||_this$onError2===void 0?void 0:_this$onError2.call(this,error);},{enableHighAccuracy:true,timeout:10000,maximumAge:5000});return true;}catch(error){var _this$onError3;console.error('Failed to start GPS tracking:',error);(_this$onError3=this.onError)===null||_this$onError3===void 0?void 0:_this$onError3.call(this,error);return false;}}stopTracking(){if(this.watchId!==null){navigator.geolocation.clearWatch(this.watchId);this.watchId=null;}}getCurrentPosition(){return new Promise(resolve=>{navigator.geolocation.getCurrentPosition(position=>resolve(position),error=>{console.error('Failed to get current position:',error);resolve(null);},{enableHighAccuracy:true,timeout:10000,maximumAge:60000});});}positionToLocation(position){return{latitude:position.coords.latitude,longitude:position.coords.longitude,accuracy:position.coords.accuracy,timestamp:position.timestamp};}// Calculate distance between two points in meters\nstatic calculateDistance(loc1,loc2){const R=6371e3;// Earth's radius in meters\nconst φ1=loc1.latitude*Math.PI/180;const φ2=loc2.latitude*Math.PI/180;const Δφ=(loc2.latitude-loc1.latitude)*Math.PI/180;const Δλ=(loc2.longitude-loc1.longitude)*Math.PI/180;const a=Math.sin(Δφ/2)*Math.sin(Δφ/2)+Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)*Math.sin(Δλ/2);const c=2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));return R*c;}// Check if location is within a certain radius of another location\nstatic isWithinRadius(center,point,radiusMeters){return this.calculateDistance(center,point)<=radiusMeters;}}","map":{"version":3,"names":["GPSService","constructor","onLocationUpdate","onError","watchId","startTracking","navigator","geolocation","_this$onError","call","GeolocationPositionError","position","getCurrentPosition","_this$onLocationUpdat","positionToLocation","watchPosition","_this$onLocationUpdat2","error","_this$onError2","console","enableHighAccuracy","timeout","maximumAge","_this$onError3","stopTracking","clearWatch","Promise","resolve","latitude","coords","longitude","accuracy","timestamp","calculateDistance","loc1","loc2","R","φ1","Math","PI","φ2","Δφ","Δλ","a","sin","cos","c","atan2","sqrt","isWithinRadius","center","point","radiusMeters"],"sources":["C:/Users/usman/.cursor/alzense/src/services/gps.ts"],"sourcesContent":["import { Location } from '../types';\r\n\r\nexport class GPSService {\r\n  private watchId: number | null = null;\r\n  private onLocationUpdate: ((location: Location) => void) | null = null;\r\n  private onError: ((error: GeolocationPositionError) => void) | null = null;\r\n\r\n  constructor(\r\n    onLocationUpdate: (location: Location) => void,\r\n    onError: (error: GeolocationPositionError) => void\r\n  ) {\r\n    this.onLocationUpdate = onLocationUpdate;\r\n    this.onError = onError;\r\n  }\r\n\r\n  async startTracking(): Promise<boolean> {\r\n    if (!navigator.geolocation) {\r\n      this.onError?.(new GeolocationPositionError());\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      // First, get current position\r\n      const position = await this.getCurrentPosition();\r\n      if (position) {\r\n        this.onLocationUpdate?.(this.positionToLocation(position));\r\n      }\r\n\r\n      // Then start watching for updates\r\n      this.watchId = navigator.geolocation.watchPosition(\r\n        (position) => {\r\n          this.onLocationUpdate?.(this.positionToLocation(position));\r\n        },\r\n        (error) => {\r\n          console.error('GPS error:', error);\r\n          this.onError?.(error);\r\n        },\r\n        {\r\n          enableHighAccuracy: true,\r\n          timeout: 10000,\r\n          maximumAge: 5000\r\n        }\r\n      );\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Failed to start GPS tracking:', error);\r\n      this.onError?.(error as GeolocationPositionError);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  stopTracking(): void {\r\n    if (this.watchId !== null) {\r\n      navigator.geolocation.clearWatch(this.watchId);\r\n      this.watchId = null;\r\n    }\r\n  }\r\n\r\n  private getCurrentPosition(): Promise<GeolocationPosition | null> {\r\n    return new Promise((resolve) => {\r\n      navigator.geolocation.getCurrentPosition(\r\n        (position) => resolve(position),\r\n        (error) => {\r\n          console.error('Failed to get current position:', error);\r\n          resolve(null);\r\n        },\r\n        {\r\n          enableHighAccuracy: true,\r\n          timeout: 10000,\r\n          maximumAge: 60000\r\n        }\r\n      );\r\n    });\r\n  }\r\n\r\n  private positionToLocation(position: GeolocationPosition): Location {\r\n    return {\r\n      latitude: position.coords.latitude,\r\n      longitude: position.coords.longitude,\r\n      accuracy: position.coords.accuracy,\r\n      timestamp: position.timestamp\r\n    };\r\n  }\r\n\r\n  // Calculate distance between two points in meters\r\n  static calculateDistance(loc1: Location, loc2: Location): number {\r\n    const R = 6371e3; // Earth's radius in meters\r\n    const φ1 = (loc1.latitude * Math.PI) / 180;\r\n    const φ2 = (loc2.latitude * Math.PI) / 180;\r\n    const Δφ = ((loc2.latitude - loc1.latitude) * Math.PI) / 180;\r\n    const Δλ = ((loc2.longitude - loc1.longitude) * Math.PI) / 180;\r\n\r\n    const a =\r\n      Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +\r\n      Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);\r\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n\r\n    return R * c;\r\n  }\r\n\r\n  // Check if location is within a certain radius of another location\r\n  static isWithinRadius(\r\n    center: Location,\r\n    point: Location,\r\n    radiusMeters: number\r\n  ): boolean {\r\n    return this.calculateDistance(center, point) <= radiusMeters;\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}