{"ast":null,"code":"import { GPSService } from './gps';\nexport class InsightsService {\n  // Generate insights for a walk session\n  static generateSessionInsights(session) {\n    const {\n      moodEntries,\n      stressCount,\n      calmCount\n    } = session;\n    if (moodEntries.length === 0) {\n      return \"No mood data recorded for this walk.\";\n    }\n    const totalEntries = moodEntries.length;\n    const stressPercentage = Math.round(stressCount / totalEntries * 100);\n    const calmPercentage = Math.round(calmCount / totalEntries * 100);\n    let insights = [];\n\n    // Overall mood summary\n    if (stressCount > calmCount) {\n      insights.push(`The walk had more stressful moments (${stressPercentage}%) than calm ones.`);\n    } else if (calmCount > stressCount) {\n      insights.push(`The walk was mostly peaceful (${calmPercentage}% calm moments).`);\n    } else {\n      insights.push(`The walk had a balanced mix of emotions.`);\n    }\n\n    // Noise correlation\n    const highNoiseEntries = moodEntries.filter(entry => entry.noiseLevel > 60);\n    const highNoiseStressed = highNoiseEntries.filter(entry => entry.mood === 'stressed');\n    if (highNoiseStressed.length > 0) {\n      const noiseStressCorrelation = Math.round(highNoiseStressed.length / highNoiseEntries.length * 100);\n      insights.push(`High noise levels (${highNoiseStressed.length} instances) often correlated with stress (${noiseStressCorrelation}% of the time).`);\n    }\n\n    // Time-based patterns\n    const morningEntries = moodEntries.filter(entry => {\n      const hour = new Date(entry.timestamp).getHours();\n      return hour >= 6 && hour < 12;\n    });\n    const afternoonEntries = moodEntries.filter(entry => {\n      const hour = new Date(entry.timestamp).getHours();\n      return hour >= 12 && hour < 18;\n    });\n    const eveningEntries = moodEntries.filter(entry => {\n      const hour = new Date(entry.timestamp).getHours();\n      return hour >= 18 || hour < 6;\n    });\n    const timeInsights = this.analyzeTimePatterns(morningEntries, afternoonEntries, eveningEntries);\n    if (timeInsights) {\n      insights.push(timeInsights);\n    }\n\n    // Location clustering\n    const locationInsights = this.analyzeLocationPatterns(moodEntries);\n    if (locationInsights) {\n      insights.push(locationInsights);\n    }\n    return insights.join(' ');\n  }\n\n  // Analyze time-based mood patterns\n  static analyzeTimePatterns(morning, afternoon, evening) {\n    const periods = [{\n      name: 'morning',\n      entries: morning\n    }, {\n      name: 'afternoon',\n      entries: afternoon\n    }, {\n      name: 'evening',\n      entries: evening\n    }];\n    const periodStressRates = periods.map(period => ({\n      name: period.name,\n      stressRate: period.entries.length > 0 ? period.entries.filter(e => e.mood === 'stressed').length / period.entries.length : 0\n    }));\n    const bestPeriod = periodStressRates.reduce((best, current) => current.stressRate < best.stressRate ? current : best);\n    const worstPeriod = periodStressRates.reduce((worst, current) => current.stressRate > worst.stressRate ? current : worst);\n    if (bestPeriod.stressRate < 0.2 && worstPeriod.stressRate > 0.4) {\n      return `Consider walking more in the ${bestPeriod.name} when stress levels are lower.`;\n    }\n    return null;\n  }\n\n  // Analyze location-based patterns\n  static analyzeLocationPatterns(entries) {\n    if (entries.length < 3) return null;\n\n    // Group nearby entries (within 50 meters)\n    const clusters = this.clusterNearbyEntries(entries, 50);\n    const clusterMoods = clusters.map(cluster => ({\n      center: cluster.center,\n      entries: cluster.entries,\n      stressRate: cluster.entries.filter(e => e.mood === 'stressed').length / cluster.entries.length,\n      calmRate: cluster.entries.filter(e => e.mood === 'calm').length / cluster.entries.length\n    }));\n    const stressClusters = clusterMoods.filter(c => c.stressRate > 0.6);\n    const calmClusters = clusterMoods.filter(c => c.calmRate > 0.6);\n    if (stressClusters.length > 0) {\n      return `Some areas consistently triggered stress. Consider avoiding these locations.`;\n    }\n    if (calmClusters.length > 0) {\n      return `Some areas consistently provided calm moments. These might be good rest spots.`;\n    }\n    return null;\n  }\n\n  // Cluster nearby mood entries\n  static clusterNearbyEntries(entries, radiusMeters) {\n    const clusters = [];\n    const processed = new Set();\n    entries.forEach(entry => {\n      if (processed.has(entry.id)) return;\n      const cluster = {\n        center: entry.location,\n        entries: [entry]\n      };\n\n      // Find nearby entries\n      entries.forEach(otherEntry => {\n        if (otherEntry.id === entry.id || processed.has(otherEntry.id)) return;\n        if (GPSService.calculateDistance(entry.location, otherEntry.location) <= radiusMeters) {\n          cluster.entries.push(otherEntry);\n          processed.add(otherEntry.id);\n        }\n      });\n      processed.add(entry.id);\n      clusters.push(cluster);\n    });\n    return clusters;\n  }\n\n  // Update calm and stress zones based on session data\n  static updateZonesFromSession(session, existingCalmZones, existingStressZones) {\n    const calmZones = [...existingCalmZones];\n    const stressZones = [...existingStressZones];\n\n    // Group entries by location clusters\n    const clusters = this.clusterNearbyEntries(session.moodEntries, 30);\n    clusters.forEach(cluster => {\n      const stressRate = cluster.entries.filter(e => e.mood === 'stressed').length / cluster.entries.length;\n      const calmRate = cluster.entries.filter(e => e.mood === 'calm').length / cluster.entries.length;\n      if (stressRate > 0.6 && cluster.entries.length >= 2) {\n        // This is a stress zone\n        const existingZone = stressZones.find(zone => GPSService.calculateDistance(zone.center, cluster.center) < 50);\n        if (existingZone) {\n          existingZone.stressCount += cluster.entries.length;\n          existingZone.stressScore = Math.min(1, existingZone.stressScore + 0.1);\n          existingZone.lastStressed = Math.max(existingZone.lastStressed, Math.max(...cluster.entries.map(e => e.timestamp)));\n        } else {\n          stressZones.push({\n            id: `stress_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n            center: cluster.center,\n            radius: 30,\n            stressScore: stressRate,\n            stressCount: cluster.entries.length,\n            lastStressed: Math.max(...cluster.entries.map(e => e.timestamp))\n          });\n        }\n      } else if (calmRate > 0.6 && cluster.entries.length >= 2) {\n        // This is a calm zone\n        const existingZone = calmZones.find(zone => GPSService.calculateDistance(zone.center, cluster.center) < 50);\n        if (existingZone) {\n          existingZone.visitCount += cluster.entries.length;\n          existingZone.calmScore = Math.min(1, existingZone.calmScore + 0.1);\n          existingZone.lastVisited = Math.max(existingZone.lastVisited, Math.max(...cluster.entries.map(e => e.timestamp)));\n        } else {\n          calmZones.push({\n            id: `calm_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n            center: cluster.center,\n            radius: 30,\n            calmScore: calmRate,\n            visitCount: cluster.entries.length,\n            lastVisited: Math.max(...cluster.entries.map(e => e.timestamp))\n          });\n        }\n      }\n    });\n    return {\n      calmZones,\n      stressZones\n    };\n  }\n\n  // Generate route suggestions\n  static generateRouteSuggestion(start, end, calmZones, stressZones) {\n    // Simple route suggestion algorithm\n    // In a real implementation, this would use a proper routing service\n\n    const waypoints = [];\n    let calmScore = 0.5; // Base score\n\n    // Try to include calm zones along the route\n    const nearbyCalmZones = calmZones.filter(zone => {\n      const distToStart = GPSService.calculateDistance(start, zone.center);\n      const distToEnd = GPSService.calculateDistance(end, zone.center);\n      return distToStart < 200 && distToEnd < 200;\n    });\n    if (nearbyCalmZones.length > 0) {\n      const bestCalmZone = nearbyCalmZones.reduce((best, current) => current.calmScore > best.calmScore ? current : best);\n      waypoints.push(bestCalmZone.center);\n      calmScore += bestCalmZone.calmScore * 0.3;\n    }\n\n    // Avoid stress zones\n    const nearbyStressZones = stressZones.filter(zone => {\n      const distToStart = GPSService.calculateDistance(start, zone.center);\n      const distToEnd = GPSService.calculateDistance(end, zone.center);\n      return distToStart < 200 && distToEnd < 200;\n    });\n    calmScore -= nearbyStressZones.length * 0.2;\n\n    // Calculate estimated duration (rough approximation)\n    const totalDistance = GPSService.calculateDistance(start, end);\n    const estimatedDuration = Math.round(totalDistance / 1000 * 12); // ~12 min per km walking\n\n    return {\n      id: `route_${Date.now()}`,\n      start,\n      end,\n      waypoints,\n      calmScore: Math.max(0, Math.min(1, calmScore)),\n      estimatedDuration,\n      avoidsStressZones: nearbyStressZones.map(zone => zone.id),\n      includesCalmZones: nearbyCalmZones.map(zone => zone.id)\n    };\n  }\n}","map":{"version":3,"names":["GPSService","InsightsService","generateSessionInsights","session","moodEntries","stressCount","calmCount","length","totalEntries","stressPercentage","Math","round","calmPercentage","insights","push","highNoiseEntries","filter","entry","noiseLevel","highNoiseStressed","mood","noiseStressCorrelation","morningEntries","hour","Date","timestamp","getHours","afternoonEntries","eveningEntries","timeInsights","analyzeTimePatterns","locationInsights","analyzeLocationPatterns","join","morning","afternoon","evening","periods","name","entries","periodStressRates","map","period","stressRate","e","bestPeriod","reduce","best","current","worstPeriod","worst","clusters","clusterNearbyEntries","clusterMoods","cluster","center","calmRate","stressClusters","c","calmClusters","radiusMeters","processed","Set","forEach","has","id","location","otherEntry","calculateDistance","add","updateZonesFromSession","existingCalmZones","existingStressZones","calmZones","stressZones","existingZone","find","zone","stressScore","min","lastStressed","max","now","random","toString","substr","radius","visitCount","calmScore","lastVisited","generateRouteSuggestion","start","end","waypoints","nearbyCalmZones","distToStart","distToEnd","bestCalmZone","nearbyStressZones","totalDistance","estimatedDuration","avoidsStressZones","includesCalmZones"],"sources":["C:/Users/usman/.cursor/alzense/src/services/insights.ts"],"sourcesContent":["import { WalkSession, MoodEntry, CalmZone, StressZone, Location } from '../types';\nimport { GPSService } from './gps';\n\nexport class InsightsService {\n  // Generate insights for a walk session\n  static generateSessionInsights(session: WalkSession): string {\n    const { moodEntries, stressCount, calmCount } = session;\n    \n    if (moodEntries.length === 0) {\n      return \"No mood data recorded for this walk.\";\n    }\n\n    const totalEntries = moodEntries.length;\n    const stressPercentage = Math.round((stressCount / totalEntries) * 100);\n    const calmPercentage = Math.round((calmCount / totalEntries) * 100);\n    \n    let insights = [];\n    \n    // Overall mood summary\n    if (stressCount > calmCount) {\n      insights.push(`The walk had more stressful moments (${stressPercentage}%) than calm ones.`);\n    } else if (calmCount > stressCount) {\n      insights.push(`The walk was mostly peaceful (${calmPercentage}% calm moments).`);\n    } else {\n      insights.push(`The walk had a balanced mix of emotions.`);\n    }\n\n    // Noise correlation\n    const highNoiseEntries = moodEntries.filter(entry => entry.noiseLevel > 60);\n    const highNoiseStressed = highNoiseEntries.filter(entry => entry.mood === 'stressed');\n    \n    if (highNoiseStressed.length > 0) {\n      const noiseStressCorrelation = Math.round((highNoiseStressed.length / highNoiseEntries.length) * 100);\n      insights.push(`High noise levels (${highNoiseStressed.length} instances) often correlated with stress (${noiseStressCorrelation}% of the time).`);\n    }\n\n    // Time-based patterns\n    const morningEntries = moodEntries.filter(entry => {\n      const hour = new Date(entry.timestamp).getHours();\n      return hour >= 6 && hour < 12;\n    });\n    const afternoonEntries = moodEntries.filter(entry => {\n      const hour = new Date(entry.timestamp).getHours();\n      return hour >= 12 && hour < 18;\n    });\n    const eveningEntries = moodEntries.filter(entry => {\n      const hour = new Date(entry.timestamp).getHours();\n      return hour >= 18 || hour < 6;\n    });\n\n    const timeInsights = this.analyzeTimePatterns(morningEntries, afternoonEntries, eveningEntries);\n    if (timeInsights) {\n      insights.push(timeInsights);\n    }\n\n    // Location clustering\n    const locationInsights = this.analyzeLocationPatterns(moodEntries);\n    if (locationInsights) {\n      insights.push(locationInsights);\n    }\n\n    return insights.join(' ');\n  }\n\n  // Analyze time-based mood patterns\n  private static analyzeTimePatterns(\n    morning: MoodEntry[],\n    afternoon: MoodEntry[],\n    evening: MoodEntry[]\n  ): string | null {\n    const periods = [\n      { name: 'morning', entries: morning },\n      { name: 'afternoon', entries: afternoon },\n      { name: 'evening', entries: evening }\n    ];\n\n    const periodStressRates = periods.map(period => ({\n      name: period.name,\n      stressRate: period.entries.length > 0 \n        ? period.entries.filter(e => e.mood === 'stressed').length / period.entries.length\n        : 0\n    }));\n\n    const bestPeriod = periodStressRates.reduce((best, current) => \n      current.stressRate < best.stressRate ? current : best\n    );\n    const worstPeriod = periodStressRates.reduce((worst, current) => \n      current.stressRate > worst.stressRate ? current : worst\n    );\n\n    if (bestPeriod.stressRate < 0.2 && worstPeriod.stressRate > 0.4) {\n      return `Consider walking more in the ${bestPeriod.name} when stress levels are lower.`;\n    }\n\n    return null;\n  }\n\n  // Analyze location-based patterns\n  private static analyzeLocationPatterns(entries: MoodEntry[]): string | null {\n    if (entries.length < 3) return null;\n\n    // Group nearby entries (within 50 meters)\n    const clusters = this.clusterNearbyEntries(entries, 50);\n    \n    const clusterMoods = clusters.map(cluster => ({\n      center: cluster.center,\n      entries: cluster.entries,\n      stressRate: cluster.entries.filter(e => e.mood === 'stressed').length / cluster.entries.length,\n      calmRate: cluster.entries.filter(e => e.mood === 'calm').length / cluster.entries.length\n    }));\n\n    const stressClusters = clusterMoods.filter(c => c.stressRate > 0.6);\n    const calmClusters = clusterMoods.filter(c => c.calmRate > 0.6);\n\n    if (stressClusters.length > 0) {\n      return `Some areas consistently triggered stress. Consider avoiding these locations.`;\n    }\n\n    if (calmClusters.length > 0) {\n      return `Some areas consistently provided calm moments. These might be good rest spots.`;\n    }\n\n    return null;\n  }\n\n  // Cluster nearby mood entries\n  private static clusterNearbyEntries(entries: MoodEntry[], radiusMeters: number) {\n    const clusters: Array<{ center: Location; entries: MoodEntry[] }> = [];\n    const processed = new Set<string>();\n\n    entries.forEach(entry => {\n      if (processed.has(entry.id)) return;\n\n      const cluster = {\n        center: entry.location,\n        entries: [entry]\n      };\n\n      // Find nearby entries\n      entries.forEach(otherEntry => {\n        if (otherEntry.id === entry.id || processed.has(otherEntry.id)) return;\n        \n        if (GPSService.calculateDistance(entry.location, otherEntry.location) <= radiusMeters) {\n          cluster.entries.push(otherEntry);\n          processed.add(otherEntry.id);\n        }\n      });\n\n      processed.add(entry.id);\n      clusters.push(cluster);\n    });\n\n    return clusters;\n  }\n\n  // Update calm and stress zones based on session data\n  static updateZonesFromSession(\n    session: WalkSession,\n    existingCalmZones: CalmZone[],\n    existingStressZones: StressZone[]\n  ): { calmZones: CalmZone[]; stressZones: StressZone[] } {\n    const calmZones = [...existingCalmZones];\n    const stressZones = [...existingStressZones];\n\n    // Group entries by location clusters\n    const clusters = this.clusterNearbyEntries(session.moodEntries, 30);\n    \n    clusters.forEach(cluster => {\n      const stressRate = cluster.entries.filter(e => e.mood === 'stressed').length / cluster.entries.length;\n      const calmRate = cluster.entries.filter(e => e.mood === 'calm').length / cluster.entries.length;\n      \n      if (stressRate > 0.6 && cluster.entries.length >= 2) {\n        // This is a stress zone\n        const existingZone = stressZones.find(zone => \n          GPSService.calculateDistance(zone.center, cluster.center) < 50\n        );\n        \n        if (existingZone) {\n          existingZone.stressCount += cluster.entries.length;\n          existingZone.stressScore = Math.min(1, existingZone.stressScore + 0.1);\n          existingZone.lastStressed = Math.max(existingZone.lastStressed, \n            Math.max(...cluster.entries.map(e => e.timestamp))\n          );\n        } else {\n          stressZones.push({\n            id: `stress_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n            center: cluster.center,\n            radius: 30,\n            stressScore: stressRate,\n            stressCount: cluster.entries.length,\n            lastStressed: Math.max(...cluster.entries.map(e => e.timestamp))\n          });\n        }\n      } else if (calmRate > 0.6 && cluster.entries.length >= 2) {\n        // This is a calm zone\n        const existingZone = calmZones.find(zone => \n          GPSService.calculateDistance(zone.center, cluster.center) < 50\n        );\n        \n        if (existingZone) {\n          existingZone.visitCount += cluster.entries.length;\n          existingZone.calmScore = Math.min(1, existingZone.calmScore + 0.1);\n          existingZone.lastVisited = Math.max(existingZone.lastVisited, \n            Math.max(...cluster.entries.map(e => e.timestamp))\n          );\n        } else {\n          calmZones.push({\n            id: `calm_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n            center: cluster.center,\n            radius: 30,\n            calmScore: calmRate,\n            visitCount: cluster.entries.length,\n            lastVisited: Math.max(...cluster.entries.map(e => e.timestamp))\n          });\n        }\n      }\n    });\n\n    return { calmZones, stressZones };\n  }\n\n  // Generate route suggestions\n  static generateRouteSuggestion(\n    start: Location,\n    end: Location,\n    calmZones: CalmZone[],\n    stressZones: StressZone[]\n  ) {\n    // Simple route suggestion algorithm\n    // In a real implementation, this would use a proper routing service\n    \n    const waypoints: Location[] = [];\n    let calmScore = 0.5; // Base score\n    \n    // Try to include calm zones along the route\n    const nearbyCalmZones = calmZones.filter(zone => {\n      const distToStart = GPSService.calculateDistance(start, zone.center);\n      const distToEnd = GPSService.calculateDistance(end, zone.center);\n      return distToStart < 200 && distToEnd < 200;\n    });\n    \n    if (nearbyCalmZones.length > 0) {\n      const bestCalmZone = nearbyCalmZones.reduce((best, current) => \n        current.calmScore > best.calmScore ? current : best\n      );\n      waypoints.push(bestCalmZone.center);\n      calmScore += bestCalmZone.calmScore * 0.3;\n    }\n    \n    // Avoid stress zones\n    const nearbyStressZones = stressZones.filter(zone => {\n      const distToStart = GPSService.calculateDistance(start, zone.center);\n      const distToEnd = GPSService.calculateDistance(end, zone.center);\n      return distToStart < 200 && distToEnd < 200;\n    });\n    \n    calmScore -= nearbyStressZones.length * 0.2;\n    \n    // Calculate estimated duration (rough approximation)\n    const totalDistance = GPSService.calculateDistance(start, end);\n    const estimatedDuration = Math.round(totalDistance / 1000 * 12); // ~12 min per km walking\n    \n    return {\n      id: `route_${Date.now()}`,\n      start,\n      end,\n      waypoints,\n      calmScore: Math.max(0, Math.min(1, calmScore)),\n      estimatedDuration,\n      avoidsStressZones: nearbyStressZones.map(zone => zone.id),\n      includesCalmZones: nearbyCalmZones.map(zone => zone.id)\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}