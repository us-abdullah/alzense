{"ast":null,"code":"import { GPSService } from './gps';\nexport class RoutingService {\n  // Free tier key - replace with your own\n\n  // Get a real walking route between two points\n  static async getWalkingRoute(start, end, calmZones, stressZones) {\n    try {\n      // First, get the basic route from OpenRouteService\n      const basicRoute = await this.getBasicRoute(start, end);\n\n      // Then optimize it based on calm/stress zones\n      const optimizedRoute = await this.optimizeRoute(basicRoute, calmZones, stressZones);\n      return optimizedRoute;\n    } catch (error) {\n      console.warn('External routing APIs failed, using enhanced fallback system:', error);\n      // Fallback to enhanced route generation\n      return this.createFallbackRoute(start, end, calmZones, stressZones);\n    }\n  }\n\n  // Get basic route from OpenRouteService\n  static async getBasicRoute(start, end) {\n    try {\n      const params = new URLSearchParams({\n        api_key: this.API_KEY,\n        start: `${start.longitude},${start.latitude}`,\n        end: `${end.longitude},${end.latitude}`,\n        profile: 'foot-walking',\n        format: 'json',\n        instructions: 'true',\n        geometry: 'true'\n      });\n      const response = await fetch(`${this.OPENROUTE_API_URL}?${params}`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      return data;\n    } catch (error) {\n      console.warn('OpenRouteService failed, trying GraphHopper...', error);\n      return await this.getGraphHopperRoute(start, end);\n    }\n  }\n\n  // Fallback to GraphHopper (free tier)\n  static async getGraphHopperRoute(start, end) {\n    try {\n      var _route$instructions;\n      // GraphHopper expects multiple 'point' parameters, not an array\n      const params = new URLSearchParams();\n      params.append('key', 'demo'); // Free demo key\n      params.append('point', `${start.latitude},${start.longitude}`);\n      params.append('point', `${end.latitude},${end.longitude}`);\n      params.append('vehicle', 'foot');\n      params.append('instructions', 'true');\n      params.append('points_encoded', 'false');\n      const response = await fetch(`https://graphhopper.com/api/1/route?${params}`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n\n      // Convert GraphHopper format to our expected format\n      const route = data.paths[0];\n      return {\n        features: [{\n          geometry: {\n            coordinates: route.points.coordinates\n          },\n          properties: {\n            summary: {\n              distance: route.distance,\n              duration: route.time / 1000 // Convert ms to seconds\n            },\n            instructions: ((_route$instructions = route.instructions) === null || _route$instructions === void 0 ? void 0 : _route$instructions.map(inst => ({\n              instruction: inst.text,\n              distance: inst.distance\n            }))) || []\n          }\n        }]\n      };\n    } catch (error) {\n      console.warn('GraphHopper also failed, using fallback route', error);\n      throw new Error('All routing services failed');\n    }\n  }\n\n  // Optimize route based on calm/stress zones\n  static async optimizeRoute(basicRoute, calmZones, stressZones) {\n    const route = basicRoute.features[0];\n    const geometry = route.geometry.coordinates;\n    const properties = route.properties;\n\n    // Convert coordinates to our format\n    const waypoints = geometry.map(coord => ({\n      longitude: coord[0],\n      latitude: coord[1]\n    }));\n\n    // Create route segments\n    const segments = [];\n    for (let i = 0; i < waypoints.length - 1; i++) {\n      const start = waypoints[i];\n      const end = waypoints[i + 1];\n      const distance = GPSService.calculateDistance({\n        latitude: start.latitude,\n        longitude: start.longitude,\n        timestamp: 0\n      }, {\n        latitude: end.latitude,\n        longitude: end.longitude,\n        timestamp: 0\n      });\n      segments.push({\n        start,\n        end,\n        distance,\n        duration: distance / 1.4 // Average walking speed: 1.4 m/s\n      });\n    }\n\n    // Calculate calm score and zone interactions\n    const {\n      calmScore,\n      avoidsStressZones,\n      includesCalmZones\n    } = this.analyzeRouteOptimization(waypoints, calmZones, stressZones);\n\n    // Generate instructions\n    const instructions = this.generateInstructions(segments, properties.instructions || []);\n    return {\n      id: `route_${Date.now()}`,\n      start: {\n        latitude: waypoints[0].latitude,\n        longitude: waypoints[0].longitude,\n        timestamp: 0\n      },\n      end: {\n        latitude: waypoints[waypoints.length - 1].latitude,\n        longitude: waypoints[waypoints.length - 1].longitude,\n        timestamp: 0\n      },\n      waypoints,\n      segments,\n      totalDistance: properties.summary.distance,\n      totalDuration: properties.summary.duration,\n      calmScore,\n      avoidsStressZones,\n      includesCalmZones,\n      instructions\n    };\n  }\n\n  // Analyze route optimization based on calm/stress zones\n  static analyzeRouteOptimization(waypoints, calmZones, stressZones) {\n    let calmScore = 0.5; // Base score\n    const avoidsStressZones = [];\n    const includesCalmZones = [];\n\n    // Check each waypoint against zones\n    waypoints.forEach(point => {\n      const pointLocation = {\n        latitude: point.latitude,\n        longitude: point.longitude,\n        timestamp: 0\n      };\n\n      // Check stress zones\n      stressZones.forEach(zone => {\n        if (GPSService.isWithinRadius(zone.center, pointLocation, zone.radius)) {\n          calmScore -= 0.1; // Penalize for going through stress zones\n          if (!avoidsStressZones.includes(zone.id)) {\n            avoidsStressZones.push(zone.id);\n          }\n        }\n      });\n\n      // Check calm zones\n      calmZones.forEach(zone => {\n        if (GPSService.isWithinRadius(zone.center, pointLocation, zone.radius)) {\n          calmScore += 0.05; // Reward for going through calm zones\n          if (!includesCalmZones.includes(zone.id)) {\n            includesCalmZones.push(zone.id);\n          }\n        }\n      });\n    });\n\n    // Normalize calm score to 0-1 range\n    calmScore = Math.max(0, Math.min(1, calmScore));\n    return {\n      calmScore,\n      avoidsStressZones,\n      includesCalmZones\n    };\n  }\n\n  // Generate human-readable instructions\n  static generateInstructions(segments, apiInstructions) {\n    const instructions = [];\n    if (apiInstructions.length > 0) {\n      // Use API instructions if available\n      apiInstructions.forEach((instruction, index) => {\n        instructions.push(`${index + 1}. ${instruction.instruction} (${Math.round(instruction.distance)}m)`);\n      });\n    } else {\n      // Generate basic instructions from segments\n      segments.forEach((segment, index) => {\n        const direction = this.getDirection(segment.start, segment.end);\n        instructions.push(`${index + 1}. Walk ${direction} for ${Math.round(segment.distance)}m`);\n      });\n    }\n    return instructions;\n  }\n\n  // Get cardinal direction between two points\n  static getDirection(start, end) {\n    const latDiff = end.latitude - start.latitude;\n    const lngDiff = end.longitude - start.longitude;\n    const angle = Math.atan2(lngDiff, latDiff) * 180 / Math.PI;\n    if (angle >= -22.5 && angle < 22.5) return 'north';\n    if (angle >= 22.5 && angle < 67.5) return 'northeast';\n    if (angle >= 67.5 && angle < 112.5) return 'east';\n    if (angle >= 112.5 && angle < 157.5) return 'southeast';\n    if (angle >= 157.5 || angle < -157.5) return 'south';\n    if (angle >= -157.5 && angle < -112.5) return 'southwest';\n    if (angle >= -112.5 && angle < -67.5) return 'west';\n    if (angle >= -67.5 && angle < -22.5) return 'northwest';\n    return 'forward';\n  }\n\n  // Create fallback route when API fails\n  static createFallbackRoute(start, end, calmZones, stressZones) {\n    const distance = GPSService.calculateDistance(start, end);\n    const duration = distance / 1.4; // Average walking speed\n\n    // Create a more realistic route with intermediate waypoints\n    const waypoints = this.generateIntermediateWaypoints(start, end);\n    const segments = [];\n    for (let i = 0; i < waypoints.length - 1; i++) {\n      const segmentDistance = GPSService.calculateDistance({\n        latitude: waypoints[i].latitude,\n        longitude: waypoints[i].longitude,\n        timestamp: 0\n      }, {\n        latitude: waypoints[i + 1].latitude,\n        longitude: waypoints[i + 1].longitude,\n        timestamp: 0\n      });\n      segments.push({\n        start: waypoints[i],\n        end: waypoints[i + 1],\n        distance: segmentDistance,\n        duration: segmentDistance / 1.4,\n        instructions: this.generateSegmentInstruction(waypoints[i], waypoints[i + 1], i)\n      });\n    }\n    const {\n      calmScore,\n      avoidsStressZones,\n      includesCalmZones\n    } = this.analyzeRouteOptimization(waypoints, calmZones, stressZones);\n    const instructions = segments.map(segment => segment.instructions).filter(Boolean);\n    return {\n      id: `route_${Date.now()}`,\n      start,\n      end,\n      waypoints,\n      segments,\n      totalDistance: distance,\n      totalDuration: duration,\n      calmScore,\n      avoidsStressZones,\n      includesCalmZones,\n      instructions\n    };\n  }\n\n  // Generate intermediate waypoints for a more realistic route\n  static generateIntermediateWaypoints(start, end) {\n    const waypoints = [];\n    const distance = GPSService.calculateDistance(start, end);\n\n    // More waypoints for longer distances\n    const steps = Math.max(3, Math.min(8, Math.floor(distance / 200)));\n    for (let i = 0; i <= steps; i++) {\n      const ratio = i / steps;\n      const lat = start.latitude + (end.latitude - start.latitude) * ratio;\n      const lng = start.longitude + (end.longitude - start.longitude) * ratio;\n\n      // Add slight variations to make the route more realistic\n      const variation = 0.0001; // Small random variation\n      const latVariation = (Math.random() - 0.5) * variation;\n      const lngVariation = (Math.random() - 0.5) * variation;\n      waypoints.push({\n        latitude: lat + latVariation,\n        longitude: lng + lngVariation\n      });\n    }\n    return waypoints;\n  }\n\n  // Generate instruction for a route segment\n  static generateSegmentInstruction(start, end, index) {\n    const distance = GPSService.calculateDistance({\n      latitude: start.latitude,\n      longitude: start.longitude,\n      timestamp: 0\n    }, {\n      latitude: end.latitude,\n      longitude: end.longitude,\n      timestamp: 0\n    });\n    if (index === 0) {\n      return `Start walking ${this.getDirection(start, end)} for ${Math.round(distance)}m`;\n    } else if (distance < 50) {\n      return `Continue for ${Math.round(distance)}m`;\n    } else {\n      return `Walk ${this.getDirection(start, end)} for ${Math.round(distance)}m`;\n    }\n  }\n\n  // Get alternative routes (if API supports it)\n  static async getAlternativeRoutes(start, end, calmZones, stressZones) {\n    try {\n      // For now, return just the main route\n      // In a full implementation, you could request multiple alternatives\n      const mainRoute = await this.getWalkingRoute(start, end, calmZones, stressZones);\n      return [mainRoute];\n    } catch (error) {\n      console.error('Error getting alternative routes:', error);\n      return [];\n    }\n  }\n\n  // Check if a route is suitable for walking (sidewalks, pedestrian areas, etc.)\n  static isWalkableRoute(route) {\n    // Basic checks - in a real implementation, you'd check against road types, sidewalks, etc.\n    return route.totalDistance < 5000 &&\n    // Max 5km walk\n    route.segments.every(segment => segment.distance < 1000); // No single segment over 1km\n  }\n\n  // Get route difficulty level\n  static getRouteDifficulty(route) {\n    const distance = route.totalDistance;\n    const calmScore = route.calmScore;\n    if (distance < 1000 && calmScore > 0.7) return 'easy';\n    if (distance < 2500 && calmScore > 0.4) return 'moderate';\n    return 'challenging';\n  }\n}\nRoutingService.OPENROUTE_API_URL = 'https://api.openrouteservice.org/v2/directions';\nRoutingService.API_KEY = '5b3ce3597851110001cf6248a8b8b8b8a8b8b8b8';","map":{"version":3,"names":["GPSService","RoutingService","getWalkingRoute","start","end","calmZones","stressZones","basicRoute","getBasicRoute","optimizedRoute","optimizeRoute","error","console","warn","createFallbackRoute","params","URLSearchParams","api_key","API_KEY","longitude","latitude","profile","format","instructions","geometry","response","fetch","OPENROUTE_API_URL","ok","Error","status","data","json","getGraphHopperRoute","_route$instructions","append","route","paths","features","coordinates","points","properties","summary","distance","duration","time","map","inst","instruction","text","waypoints","coord","segments","i","length","calculateDistance","timestamp","push","calmScore","avoidsStressZones","includesCalmZones","analyzeRouteOptimization","generateInstructions","id","Date","now","totalDistance","totalDuration","forEach","point","pointLocation","zone","isWithinRadius","center","radius","includes","Math","max","min","apiInstructions","index","round","segment","direction","getDirection","latDiff","lngDiff","angle","atan2","PI","generateIntermediateWaypoints","segmentDistance","generateSegmentInstruction","filter","Boolean","steps","floor","ratio","lat","lng","variation","latVariation","random","lngVariation","getAlternativeRoutes","mainRoute","isWalkableRoute","every","getRouteDifficulty"],"sources":["C:/Users/usman/.cursor/alzense/src/services/routing.ts"],"sourcesContent":["import { Location, CalmZone, StressZone } from '../types';\r\nimport { GPSService } from './gps';\r\n\r\nexport interface RoutePoint {\r\n  latitude: number;\r\n  longitude: number;\r\n}\r\n\r\nexport interface RouteSegment {\r\n  start: RoutePoint;\r\n  end: RoutePoint;\r\n  distance: number; // in meters\r\n  duration: number; // in seconds\r\n  instructions?: string;\r\n}\r\n\r\nexport interface OptimizedRoute {\r\n  id: string;\r\n  start: Location;\r\n  end: Location;\r\n  waypoints: RoutePoint[];\r\n  segments: RouteSegment[];\r\n  totalDistance: number; // in meters\r\n  totalDuration: number; // in seconds\r\n  calmScore: number; // 0-1, higher is calmer\r\n  avoidsStressZones: string[];\r\n  includesCalmZones: string[];\r\n  instructions: string[];\r\n}\r\n\r\nexport class RoutingService {\r\n  private static readonly OPENROUTE_API_URL = 'https://api.openrouteservice.org/v2/directions';\r\n  private static readonly API_KEY = '5b3ce3597851110001cf6248a8b8b8b8a8b8b8b8'; // Free tier key - replace with your own\r\n\r\n  // Get a real walking route between two points\r\n  static async getWalkingRoute(\r\n    start: Location,\r\n    end: Location,\r\n    calmZones: CalmZone[],\r\n    stressZones: StressZone[]\r\n  ): Promise<OptimizedRoute> {\r\n    try {\r\n      // First, get the basic route from OpenRouteService\r\n      const basicRoute = await this.getBasicRoute(start, end);\r\n      \r\n      // Then optimize it based on calm/stress zones\r\n      const optimizedRoute = await this.optimizeRoute(basicRoute, calmZones, stressZones);\r\n      \r\n      return optimizedRoute;\r\n    } catch (error) {\r\n      console.warn('External routing APIs failed, using enhanced fallback system:', error);\r\n      // Fallback to enhanced route generation\r\n      return this.createFallbackRoute(start, end, calmZones, stressZones);\r\n    }\r\n  }\r\n\r\n  // Get basic route from OpenRouteService\r\n  private static async getBasicRoute(start: Location, end: Location): Promise<any> {\r\n    try {\r\n      const params = new URLSearchParams({\r\n        api_key: this.API_KEY,\r\n        start: `${start.longitude},${start.latitude}`,\r\n        end: `${end.longitude},${end.latitude}`,\r\n        profile: 'foot-walking',\r\n        format: 'json',\r\n        instructions: 'true',\r\n        geometry: 'true'\r\n      });\r\n\r\n      const response = await fetch(`${this.OPENROUTE_API_URL}?${params}`);\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n      \r\n      const data = await response.json();\r\n      return data;\r\n    } catch (error) {\r\n      console.warn('OpenRouteService failed, trying GraphHopper...', error);\r\n      return await this.getGraphHopperRoute(start, end);\r\n    }\r\n  }\r\n\r\n  // Fallback to GraphHopper (free tier)\r\n  private static async getGraphHopperRoute(start: Location, end: Location): Promise<any> {\r\n    try {\r\n      // GraphHopper expects multiple 'point' parameters, not an array\r\n      const params = new URLSearchParams();\r\n      params.append('key', 'demo'); // Free demo key\r\n      params.append('point', `${start.latitude},${start.longitude}`);\r\n      params.append('point', `${end.latitude},${end.longitude}`);\r\n      params.append('vehicle', 'foot');\r\n      params.append('instructions', 'true');\r\n      params.append('points_encoded', 'false');\r\n\r\n      const response = await fetch(`https://graphhopper.com/api/1/route?${params}`);\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n      \r\n      const data = await response.json();\r\n\r\n      // Convert GraphHopper format to our expected format\r\n      const route = data.paths[0];\r\n      return {\r\n        features: [{\r\n          geometry: {\r\n            coordinates: route.points.coordinates\r\n          },\r\n          properties: {\r\n            summary: {\r\n              distance: route.distance,\r\n              duration: route.time / 1000 // Convert ms to seconds\r\n            },\r\n            instructions: route.instructions?.map((inst: any) => ({\r\n              instruction: inst.text,\r\n              distance: inst.distance\r\n            })) || []\r\n          }\r\n        }]\r\n      };\r\n    } catch (error) {\r\n      console.warn('GraphHopper also failed, using fallback route', error);\r\n      throw new Error('All routing services failed');\r\n    }\r\n  }\r\n\r\n  // Optimize route based on calm/stress zones\r\n  private static async optimizeRoute(\r\n    basicRoute: any,\r\n    calmZones: CalmZone[],\r\n    stressZones: StressZone[]\r\n  ): Promise<OptimizedRoute> {\r\n    const route = basicRoute.features[0];\r\n    const geometry = route.geometry.coordinates;\r\n    const properties = route.properties;\r\n    \r\n    // Convert coordinates to our format\r\n    const waypoints: RoutePoint[] = geometry.map((coord: number[]) => ({\r\n      longitude: coord[0],\r\n      latitude: coord[1]\r\n    }));\r\n\r\n    // Create route segments\r\n    const segments: RouteSegment[] = [];\r\n    for (let i = 0; i < waypoints.length - 1; i++) {\r\n      const start = waypoints[i];\r\n      const end = waypoints[i + 1];\r\n      const distance = GPSService.calculateDistance(\r\n        { latitude: start.latitude, longitude: start.longitude, timestamp: 0 },\r\n        { latitude: end.latitude, longitude: end.longitude, timestamp: 0 }\r\n      );\r\n      \r\n      segments.push({\r\n        start,\r\n        end,\r\n        distance,\r\n        duration: distance / 1.4 // Average walking speed: 1.4 m/s\r\n      });\r\n    }\r\n\r\n    // Calculate calm score and zone interactions\r\n    const { calmScore, avoidsStressZones, includesCalmZones } = this.analyzeRouteOptimization(\r\n      waypoints,\r\n      calmZones,\r\n      stressZones\r\n    );\r\n\r\n    // Generate instructions\r\n    const instructions = this.generateInstructions(segments, properties.instructions || []);\r\n\r\n    return {\r\n      id: `route_${Date.now()}`,\r\n      start: { latitude: waypoints[0].latitude, longitude: waypoints[0].longitude, timestamp: 0 },\r\n      end: { latitude: waypoints[waypoints.length - 1].latitude, longitude: waypoints[waypoints.length - 1].longitude, timestamp: 0 },\r\n      waypoints,\r\n      segments,\r\n      totalDistance: properties.summary.distance,\r\n      totalDuration: properties.summary.duration,\r\n      calmScore,\r\n      avoidsStressZones,\r\n      includesCalmZones,\r\n      instructions\r\n    };\r\n  }\r\n\r\n  // Analyze route optimization based on calm/stress zones\r\n  private static analyzeRouteOptimization(\r\n    waypoints: RoutePoint[],\r\n    calmZones: CalmZone[],\r\n    stressZones: StressZone[]\r\n  ): { calmScore: number; avoidsStressZones: string[]; includesCalmZones: string[] } {\r\n    let calmScore = 0.5; // Base score\r\n    const avoidsStressZones: string[] = [];\r\n    const includesCalmZones: string[] = [];\r\n\r\n    // Check each waypoint against zones\r\n    waypoints.forEach(point => {\r\n      const pointLocation = { latitude: point.latitude, longitude: point.longitude, timestamp: 0 };\r\n      \r\n      // Check stress zones\r\n      stressZones.forEach(zone => {\r\n        if (GPSService.isWithinRadius(zone.center, pointLocation, zone.radius)) {\r\n          calmScore -= 0.1; // Penalize for going through stress zones\r\n          if (!avoidsStressZones.includes(zone.id)) {\r\n            avoidsStressZones.push(zone.id);\r\n          }\r\n        }\r\n      });\r\n\r\n      // Check calm zones\r\n      calmZones.forEach(zone => {\r\n        if (GPSService.isWithinRadius(zone.center, pointLocation, zone.radius)) {\r\n          calmScore += 0.05; // Reward for going through calm zones\r\n          if (!includesCalmZones.includes(zone.id)) {\r\n            includesCalmZones.push(zone.id);\r\n          }\r\n        }\r\n      });\r\n    });\r\n\r\n    // Normalize calm score to 0-1 range\r\n    calmScore = Math.max(0, Math.min(1, calmScore));\r\n\r\n    return { calmScore, avoidsStressZones, includesCalmZones };\r\n  }\r\n\r\n  // Generate human-readable instructions\r\n  private static generateInstructions(segments: RouteSegment[], apiInstructions: any[]): string[] {\r\n    const instructions: string[] = [];\r\n    \r\n    if (apiInstructions.length > 0) {\r\n      // Use API instructions if available\r\n      apiInstructions.forEach((instruction, index) => {\r\n        instructions.push(`${index + 1}. ${instruction.instruction} (${Math.round(instruction.distance)}m)`);\r\n      });\r\n    } else {\r\n      // Generate basic instructions from segments\r\n      segments.forEach((segment, index) => {\r\n        const direction = this.getDirection(segment.start, segment.end);\r\n        instructions.push(`${index + 1}. Walk ${direction} for ${Math.round(segment.distance)}m`);\r\n      });\r\n    }\r\n\r\n    return instructions;\r\n  }\r\n\r\n  // Get cardinal direction between two points\r\n  private static getDirection(start: RoutePoint, end: RoutePoint): string {\r\n    const latDiff = end.latitude - start.latitude;\r\n    const lngDiff = end.longitude - start.longitude;\r\n    const angle = Math.atan2(lngDiff, latDiff) * 180 / Math.PI;\r\n    \r\n    if (angle >= -22.5 && angle < 22.5) return 'north';\r\n    if (angle >= 22.5 && angle < 67.5) return 'northeast';\r\n    if (angle >= 67.5 && angle < 112.5) return 'east';\r\n    if (angle >= 112.5 && angle < 157.5) return 'southeast';\r\n    if (angle >= 157.5 || angle < -157.5) return 'south';\r\n    if (angle >= -157.5 && angle < -112.5) return 'southwest';\r\n    if (angle >= -112.5 && angle < -67.5) return 'west';\r\n    if (angle >= -67.5 && angle < -22.5) return 'northwest';\r\n    \r\n    return 'forward';\r\n  }\r\n\r\n  // Create fallback route when API fails\r\n  private static createFallbackRoute(\r\n    start: Location,\r\n    end: Location,\r\n    calmZones: CalmZone[],\r\n    stressZones: StressZone[]\r\n  ): OptimizedRoute {\r\n    const distance = GPSService.calculateDistance(start, end);\r\n    const duration = distance / 1.4; // Average walking speed\r\n    \r\n    // Create a more realistic route with intermediate waypoints\r\n    const waypoints: RoutePoint[] = this.generateIntermediateWaypoints(start, end);\r\n    \r\n    const segments: RouteSegment[] = [];\r\n    for (let i = 0; i < waypoints.length - 1; i++) {\r\n      const segmentDistance = GPSService.calculateDistance(\r\n        { latitude: waypoints[i].latitude, longitude: waypoints[i].longitude, timestamp: 0 },\r\n        { latitude: waypoints[i + 1].latitude, longitude: waypoints[i + 1].longitude, timestamp: 0 }\r\n      );\r\n      \r\n      segments.push({\r\n        start: waypoints[i],\r\n        end: waypoints[i + 1],\r\n        distance: segmentDistance,\r\n        duration: segmentDistance / 1.4,\r\n        instructions: this.generateSegmentInstruction(waypoints[i], waypoints[i + 1], i)\r\n      });\r\n    }\r\n\r\n    const { calmScore, avoidsStressZones, includesCalmZones } = this.analyzeRouteOptimization(\r\n      waypoints,\r\n      calmZones,\r\n      stressZones\r\n    );\r\n\r\n    const instructions = segments.map(segment => segment.instructions).filter(Boolean) as string[];\r\n\r\n    return {\r\n      id: `route_${Date.now()}`,\r\n      start,\r\n      end,\r\n      waypoints,\r\n      segments,\r\n      totalDistance: distance,\r\n      totalDuration: duration,\r\n      calmScore,\r\n      avoidsStressZones,\r\n      includesCalmZones,\r\n      instructions\r\n    };\r\n  }\r\n\r\n  // Generate intermediate waypoints for a more realistic route\r\n  private static generateIntermediateWaypoints(start: Location, end: Location): RoutePoint[] {\r\n    const waypoints: RoutePoint[] = [];\r\n    const distance = GPSService.calculateDistance(start, end);\r\n    \r\n    // More waypoints for longer distances\r\n    const steps = Math.max(3, Math.min(8, Math.floor(distance / 200)));\r\n    \r\n    for (let i = 0; i <= steps; i++) {\r\n      const ratio = i / steps;\r\n      const lat = start.latitude + (end.latitude - start.latitude) * ratio;\r\n      const lng = start.longitude + (end.longitude - start.longitude) * ratio;\r\n      \r\n      // Add slight variations to make the route more realistic\r\n      const variation = 0.0001; // Small random variation\r\n      const latVariation = (Math.random() - 0.5) * variation;\r\n      const lngVariation = (Math.random() - 0.5) * variation;\r\n      \r\n      waypoints.push({ \r\n        latitude: lat + latVariation, \r\n        longitude: lng + lngVariation \r\n      });\r\n    }\r\n    \r\n    return waypoints;\r\n  }\r\n\r\n  // Generate instruction for a route segment\r\n  private static generateSegmentInstruction(start: RoutePoint, end: RoutePoint, index: number): string {\r\n    const distance = GPSService.calculateDistance(\r\n      { latitude: start.latitude, longitude: start.longitude, timestamp: 0 },\r\n      { latitude: end.latitude, longitude: end.longitude, timestamp: 0 }\r\n    );\r\n    \r\n    if (index === 0) {\r\n      return `Start walking ${this.getDirection(start, end)} for ${Math.round(distance)}m`;\r\n    } else if (distance < 50) {\r\n      return `Continue for ${Math.round(distance)}m`;\r\n    } else {\r\n      return `Walk ${this.getDirection(start, end)} for ${Math.round(distance)}m`;\r\n    }\r\n  }\r\n\r\n  // Get alternative routes (if API supports it)\r\n  static async getAlternativeRoutes(\r\n    start: Location,\r\n    end: Location,\r\n    calmZones: CalmZone[],\r\n    stressZones: StressZone[]\r\n  ): Promise<OptimizedRoute[]> {\r\n    try {\r\n      // For now, return just the main route\r\n      // In a full implementation, you could request multiple alternatives\r\n      const mainRoute = await this.getWalkingRoute(start, end, calmZones, stressZones);\r\n      return [mainRoute];\r\n    } catch (error) {\r\n      console.error('Error getting alternative routes:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  // Check if a route is suitable for walking (sidewalks, pedestrian areas, etc.)\r\n  static isWalkableRoute(route: OptimizedRoute): boolean {\r\n    // Basic checks - in a real implementation, you'd check against road types, sidewalks, etc.\r\n    return route.totalDistance < 5000 && // Max 5km walk\r\n           route.segments.every(segment => segment.distance < 1000); // No single segment over 1km\r\n  }\r\n\r\n  // Get route difficulty level\r\n  static getRouteDifficulty(route: OptimizedRoute): 'easy' | 'moderate' | 'challenging' {\r\n    const distance = route.totalDistance;\r\n    const calmScore = route.calmScore;\r\n    \r\n    if (distance < 1000 && calmScore > 0.7) return 'easy';\r\n    if (distance < 2500 && calmScore > 0.4) return 'moderate';\r\n    return 'challenging';\r\n  }\r\n}\r\n"],"mappings":"AACA,SAASA,UAAU,QAAQ,OAAO;AA6BlC,OAAO,MAAMC,cAAc,CAAC;EAEoD;;EAE9E;EACA,aAAaC,eAAeA,CAC1BC,KAAe,EACfC,GAAa,EACbC,SAAqB,EACrBC,WAAyB,EACA;IACzB,IAAI;MACF;MACA,MAAMC,UAAU,GAAG,MAAM,IAAI,CAACC,aAAa,CAACL,KAAK,EAAEC,GAAG,CAAC;;MAEvD;MACA,MAAMK,cAAc,GAAG,MAAM,IAAI,CAACC,aAAa,CAACH,UAAU,EAAEF,SAAS,EAAEC,WAAW,CAAC;MAEnF,OAAOG,cAAc;IACvB,CAAC,CAAC,OAAOE,KAAK,EAAE;MACdC,OAAO,CAACC,IAAI,CAAC,+DAA+D,EAAEF,KAAK,CAAC;MACpF;MACA,OAAO,IAAI,CAACG,mBAAmB,CAACX,KAAK,EAAEC,GAAG,EAAEC,SAAS,EAAEC,WAAW,CAAC;IACrE;EACF;;EAEA;EACA,aAAqBE,aAAaA,CAACL,KAAe,EAAEC,GAAa,EAAgB;IAC/E,IAAI;MACF,MAAMW,MAAM,GAAG,IAAIC,eAAe,CAAC;QACjCC,OAAO,EAAE,IAAI,CAACC,OAAO;QACrBf,KAAK,EAAE,GAAGA,KAAK,CAACgB,SAAS,IAAIhB,KAAK,CAACiB,QAAQ,EAAE;QAC7ChB,GAAG,EAAE,GAAGA,GAAG,CAACe,SAAS,IAAIf,GAAG,CAACgB,QAAQ,EAAE;QACvCC,OAAO,EAAE,cAAc;QACvBC,MAAM,EAAE,MAAM;QACdC,YAAY,EAAE,MAAM;QACpBC,QAAQ,EAAE;MACZ,CAAC,CAAC;MAEF,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAAC,GAAG,IAAI,CAACC,iBAAiB,IAAIZ,MAAM,EAAE,CAAC;MAEnE,IAAI,CAACU,QAAQ,CAACG,EAAE,EAAE;QAChB,MAAM,IAAIC,KAAK,CAAC,uBAAuBJ,QAAQ,CAACK,MAAM,EAAE,CAAC;MAC3D;MAEA,MAAMC,IAAI,GAAG,MAAMN,QAAQ,CAACO,IAAI,CAAC,CAAC;MAClC,OAAOD,IAAI;IACb,CAAC,CAAC,OAAOpB,KAAK,EAAE;MACdC,OAAO,CAACC,IAAI,CAAC,gDAAgD,EAAEF,KAAK,CAAC;MACrE,OAAO,MAAM,IAAI,CAACsB,mBAAmB,CAAC9B,KAAK,EAAEC,GAAG,CAAC;IACnD;EACF;;EAEA;EACA,aAAqB6B,mBAAmBA,CAAC9B,KAAe,EAAEC,GAAa,EAAgB;IACrF,IAAI;MAAA,IAAA8B,mBAAA;MACF;MACA,MAAMnB,MAAM,GAAG,IAAIC,eAAe,CAAC,CAAC;MACpCD,MAAM,CAACoB,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC,CAAC;MAC9BpB,MAAM,CAACoB,MAAM,CAAC,OAAO,EAAE,GAAGhC,KAAK,CAACiB,QAAQ,IAAIjB,KAAK,CAACgB,SAAS,EAAE,CAAC;MAC9DJ,MAAM,CAACoB,MAAM,CAAC,OAAO,EAAE,GAAG/B,GAAG,CAACgB,QAAQ,IAAIhB,GAAG,CAACe,SAAS,EAAE,CAAC;MAC1DJ,MAAM,CAACoB,MAAM,CAAC,SAAS,EAAE,MAAM,CAAC;MAChCpB,MAAM,CAACoB,MAAM,CAAC,cAAc,EAAE,MAAM,CAAC;MACrCpB,MAAM,CAACoB,MAAM,CAAC,gBAAgB,EAAE,OAAO,CAAC;MAExC,MAAMV,QAAQ,GAAG,MAAMC,KAAK,CAAC,uCAAuCX,MAAM,EAAE,CAAC;MAE7E,IAAI,CAACU,QAAQ,CAACG,EAAE,EAAE;QAChB,MAAM,IAAIC,KAAK,CAAC,uBAAuBJ,QAAQ,CAACK,MAAM,EAAE,CAAC;MAC3D;MAEA,MAAMC,IAAI,GAAG,MAAMN,QAAQ,CAACO,IAAI,CAAC,CAAC;;MAElC;MACA,MAAMI,KAAK,GAAGL,IAAI,CAACM,KAAK,CAAC,CAAC,CAAC;MAC3B,OAAO;QACLC,QAAQ,EAAE,CAAC;UACTd,QAAQ,EAAE;YACRe,WAAW,EAAEH,KAAK,CAACI,MAAM,CAACD;UAC5B,CAAC;UACDE,UAAU,EAAE;YACVC,OAAO,EAAE;cACPC,QAAQ,EAAEP,KAAK,CAACO,QAAQ;cACxBC,QAAQ,EAAER,KAAK,CAACS,IAAI,GAAG,IAAI,CAAC;YAC9B,CAAC;YACDtB,YAAY,EAAE,EAAAW,mBAAA,GAAAE,KAAK,CAACb,YAAY,cAAAW,mBAAA,uBAAlBA,mBAAA,CAAoBY,GAAG,CAAEC,IAAS,KAAM;cACpDC,WAAW,EAAED,IAAI,CAACE,IAAI;cACtBN,QAAQ,EAAEI,IAAI,CAACJ;YACjB,CAAC,CAAC,CAAC,KAAI;UACT;QACF,CAAC;MACH,CAAC;IACH,CAAC,CAAC,OAAOhC,KAAK,EAAE;MACdC,OAAO,CAACC,IAAI,CAAC,+CAA+C,EAAEF,KAAK,CAAC;MACpE,MAAM,IAAIkB,KAAK,CAAC,6BAA6B,CAAC;IAChD;EACF;;EAEA;EACA,aAAqBnB,aAAaA,CAChCH,UAAe,EACfF,SAAqB,EACrBC,WAAyB,EACA;IACzB,MAAM8B,KAAK,GAAG7B,UAAU,CAAC+B,QAAQ,CAAC,CAAC,CAAC;IACpC,MAAMd,QAAQ,GAAGY,KAAK,CAACZ,QAAQ,CAACe,WAAW;IAC3C,MAAME,UAAU,GAAGL,KAAK,CAACK,UAAU;;IAEnC;IACA,MAAMS,SAAuB,GAAG1B,QAAQ,CAACsB,GAAG,CAAEK,KAAe,KAAM;MACjEhC,SAAS,EAAEgC,KAAK,CAAC,CAAC,CAAC;MACnB/B,QAAQ,EAAE+B,KAAK,CAAC,CAAC;IACnB,CAAC,CAAC,CAAC;;IAEH;IACA,MAAMC,QAAwB,GAAG,EAAE;IACnC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,SAAS,CAACI,MAAM,GAAG,CAAC,EAAED,CAAC,EAAE,EAAE;MAC7C,MAAMlD,KAAK,GAAG+C,SAAS,CAACG,CAAC,CAAC;MAC1B,MAAMjD,GAAG,GAAG8C,SAAS,CAACG,CAAC,GAAG,CAAC,CAAC;MAC5B,MAAMV,QAAQ,GAAG3C,UAAU,CAACuD,iBAAiB,CAC3C;QAAEnC,QAAQ,EAAEjB,KAAK,CAACiB,QAAQ;QAAED,SAAS,EAAEhB,KAAK,CAACgB,SAAS;QAAEqC,SAAS,EAAE;MAAE,CAAC,EACtE;QAAEpC,QAAQ,EAAEhB,GAAG,CAACgB,QAAQ;QAAED,SAAS,EAAEf,GAAG,CAACe,SAAS;QAAEqC,SAAS,EAAE;MAAE,CACnE,CAAC;MAEDJ,QAAQ,CAACK,IAAI,CAAC;QACZtD,KAAK;QACLC,GAAG;QACHuC,QAAQ;QACRC,QAAQ,EAAED,QAAQ,GAAG,GAAG,CAAC;MAC3B,CAAC,CAAC;IACJ;;IAEA;IACA,MAAM;MAAEe,SAAS;MAAEC,iBAAiB;MAAEC;IAAkB,CAAC,GAAG,IAAI,CAACC,wBAAwB,CACvFX,SAAS,EACT7C,SAAS,EACTC,WACF,CAAC;;IAED;IACA,MAAMiB,YAAY,GAAG,IAAI,CAACuC,oBAAoB,CAACV,QAAQ,EAAEX,UAAU,CAAClB,YAAY,IAAI,EAAE,CAAC;IAEvF,OAAO;MACLwC,EAAE,EAAE,SAASC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE;MACzB9D,KAAK,EAAE;QAAEiB,QAAQ,EAAE8B,SAAS,CAAC,CAAC,CAAC,CAAC9B,QAAQ;QAAED,SAAS,EAAE+B,SAAS,CAAC,CAAC,CAAC,CAAC/B,SAAS;QAAEqC,SAAS,EAAE;MAAE,CAAC;MAC3FpD,GAAG,EAAE;QAAEgB,QAAQ,EAAE8B,SAAS,CAACA,SAAS,CAACI,MAAM,GAAG,CAAC,CAAC,CAAClC,QAAQ;QAAED,SAAS,EAAE+B,SAAS,CAACA,SAAS,CAACI,MAAM,GAAG,CAAC,CAAC,CAACnC,SAAS;QAAEqC,SAAS,EAAE;MAAE,CAAC;MAC/HN,SAAS;MACTE,QAAQ;MACRc,aAAa,EAAEzB,UAAU,CAACC,OAAO,CAACC,QAAQ;MAC1CwB,aAAa,EAAE1B,UAAU,CAACC,OAAO,CAACE,QAAQ;MAC1Cc,SAAS;MACTC,iBAAiB;MACjBC,iBAAiB;MACjBrC;IACF,CAAC;EACH;;EAEA;EACA,OAAesC,wBAAwBA,CACrCX,SAAuB,EACvB7C,SAAqB,EACrBC,WAAyB,EACwD;IACjF,IAAIoD,SAAS,GAAG,GAAG,CAAC,CAAC;IACrB,MAAMC,iBAA2B,GAAG,EAAE;IACtC,MAAMC,iBAA2B,GAAG,EAAE;;IAEtC;IACAV,SAAS,CAACkB,OAAO,CAACC,KAAK,IAAI;MACzB,MAAMC,aAAa,GAAG;QAAElD,QAAQ,EAAEiD,KAAK,CAACjD,QAAQ;QAAED,SAAS,EAAEkD,KAAK,CAAClD,SAAS;QAAEqC,SAAS,EAAE;MAAE,CAAC;;MAE5F;MACAlD,WAAW,CAAC8D,OAAO,CAACG,IAAI,IAAI;QAC1B,IAAIvE,UAAU,CAACwE,cAAc,CAACD,IAAI,CAACE,MAAM,EAAEH,aAAa,EAAEC,IAAI,CAACG,MAAM,CAAC,EAAE;UACtEhB,SAAS,IAAI,GAAG,CAAC,CAAC;UAClB,IAAI,CAACC,iBAAiB,CAACgB,QAAQ,CAACJ,IAAI,CAACR,EAAE,CAAC,EAAE;YACxCJ,iBAAiB,CAACF,IAAI,CAACc,IAAI,CAACR,EAAE,CAAC;UACjC;QACF;MACF,CAAC,CAAC;;MAEF;MACA1D,SAAS,CAAC+D,OAAO,CAACG,IAAI,IAAI;QACxB,IAAIvE,UAAU,CAACwE,cAAc,CAACD,IAAI,CAACE,MAAM,EAAEH,aAAa,EAAEC,IAAI,CAACG,MAAM,CAAC,EAAE;UACtEhB,SAAS,IAAI,IAAI,CAAC,CAAC;UACnB,IAAI,CAACE,iBAAiB,CAACe,QAAQ,CAACJ,IAAI,CAACR,EAAE,CAAC,EAAE;YACxCH,iBAAiB,CAACH,IAAI,CAACc,IAAI,CAACR,EAAE,CAAC;UACjC;QACF;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;;IAEF;IACAL,SAAS,GAAGkB,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACE,GAAG,CAAC,CAAC,EAAEpB,SAAS,CAAC,CAAC;IAE/C,OAAO;MAAEA,SAAS;MAAEC,iBAAiB;MAAEC;IAAkB,CAAC;EAC5D;;EAEA;EACA,OAAeE,oBAAoBA,CAACV,QAAwB,EAAE2B,eAAsB,EAAY;IAC9F,MAAMxD,YAAsB,GAAG,EAAE;IAEjC,IAAIwD,eAAe,CAACzB,MAAM,GAAG,CAAC,EAAE;MAC9B;MACAyB,eAAe,CAACX,OAAO,CAAC,CAACpB,WAAW,EAAEgC,KAAK,KAAK;QAC9CzD,YAAY,CAACkC,IAAI,CAAC,GAAGuB,KAAK,GAAG,CAAC,KAAKhC,WAAW,CAACA,WAAW,KAAK4B,IAAI,CAACK,KAAK,CAACjC,WAAW,CAACL,QAAQ,CAAC,IAAI,CAAC;MACtG,CAAC,CAAC;IACJ,CAAC,MAAM;MACL;MACAS,QAAQ,CAACgB,OAAO,CAAC,CAACc,OAAO,EAAEF,KAAK,KAAK;QACnC,MAAMG,SAAS,GAAG,IAAI,CAACC,YAAY,CAACF,OAAO,CAAC/E,KAAK,EAAE+E,OAAO,CAAC9E,GAAG,CAAC;QAC/DmB,YAAY,CAACkC,IAAI,CAAC,GAAGuB,KAAK,GAAG,CAAC,UAAUG,SAAS,QAAQP,IAAI,CAACK,KAAK,CAACC,OAAO,CAACvC,QAAQ,CAAC,GAAG,CAAC;MAC3F,CAAC,CAAC;IACJ;IAEA,OAAOpB,YAAY;EACrB;;EAEA;EACA,OAAe6D,YAAYA,CAACjF,KAAiB,EAAEC,GAAe,EAAU;IACtE,MAAMiF,OAAO,GAAGjF,GAAG,CAACgB,QAAQ,GAAGjB,KAAK,CAACiB,QAAQ;IAC7C,MAAMkE,OAAO,GAAGlF,GAAG,CAACe,SAAS,GAAGhB,KAAK,CAACgB,SAAS;IAC/C,MAAMoE,KAAK,GAAGX,IAAI,CAACY,KAAK,CAACF,OAAO,EAAED,OAAO,CAAC,GAAG,GAAG,GAAGT,IAAI,CAACa,EAAE;IAE1D,IAAIF,KAAK,IAAI,CAAC,IAAI,IAAIA,KAAK,GAAG,IAAI,EAAE,OAAO,OAAO;IAClD,IAAIA,KAAK,IAAI,IAAI,IAAIA,KAAK,GAAG,IAAI,EAAE,OAAO,WAAW;IACrD,IAAIA,KAAK,IAAI,IAAI,IAAIA,KAAK,GAAG,KAAK,EAAE,OAAO,MAAM;IACjD,IAAIA,KAAK,IAAI,KAAK,IAAIA,KAAK,GAAG,KAAK,EAAE,OAAO,WAAW;IACvD,IAAIA,KAAK,IAAI,KAAK,IAAIA,KAAK,GAAG,CAAC,KAAK,EAAE,OAAO,OAAO;IACpD,IAAIA,KAAK,IAAI,CAAC,KAAK,IAAIA,KAAK,GAAG,CAAC,KAAK,EAAE,OAAO,WAAW;IACzD,IAAIA,KAAK,IAAI,CAAC,KAAK,IAAIA,KAAK,GAAG,CAAC,IAAI,EAAE,OAAO,MAAM;IACnD,IAAIA,KAAK,IAAI,CAAC,IAAI,IAAIA,KAAK,GAAG,CAAC,IAAI,EAAE,OAAO,WAAW;IAEvD,OAAO,SAAS;EAClB;;EAEA;EACA,OAAezE,mBAAmBA,CAChCX,KAAe,EACfC,GAAa,EACbC,SAAqB,EACrBC,WAAyB,EACT;IAChB,MAAMqC,QAAQ,GAAG3C,UAAU,CAACuD,iBAAiB,CAACpD,KAAK,EAAEC,GAAG,CAAC;IACzD,MAAMwC,QAAQ,GAAGD,QAAQ,GAAG,GAAG,CAAC,CAAC;;IAEjC;IACA,MAAMO,SAAuB,GAAG,IAAI,CAACwC,6BAA6B,CAACvF,KAAK,EAAEC,GAAG,CAAC;IAE9E,MAAMgD,QAAwB,GAAG,EAAE;IACnC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,SAAS,CAACI,MAAM,GAAG,CAAC,EAAED,CAAC,EAAE,EAAE;MAC7C,MAAMsC,eAAe,GAAG3F,UAAU,CAACuD,iBAAiB,CAClD;QAAEnC,QAAQ,EAAE8B,SAAS,CAACG,CAAC,CAAC,CAACjC,QAAQ;QAAED,SAAS,EAAE+B,SAAS,CAACG,CAAC,CAAC,CAAClC,SAAS;QAAEqC,SAAS,EAAE;MAAE,CAAC,EACpF;QAAEpC,QAAQ,EAAE8B,SAAS,CAACG,CAAC,GAAG,CAAC,CAAC,CAACjC,QAAQ;QAAED,SAAS,EAAE+B,SAAS,CAACG,CAAC,GAAG,CAAC,CAAC,CAAClC,SAAS;QAAEqC,SAAS,EAAE;MAAE,CAC7F,CAAC;MAEDJ,QAAQ,CAACK,IAAI,CAAC;QACZtD,KAAK,EAAE+C,SAAS,CAACG,CAAC,CAAC;QACnBjD,GAAG,EAAE8C,SAAS,CAACG,CAAC,GAAG,CAAC,CAAC;QACrBV,QAAQ,EAAEgD,eAAe;QACzB/C,QAAQ,EAAE+C,eAAe,GAAG,GAAG;QAC/BpE,YAAY,EAAE,IAAI,CAACqE,0BAA0B,CAAC1C,SAAS,CAACG,CAAC,CAAC,EAAEH,SAAS,CAACG,CAAC,GAAG,CAAC,CAAC,EAAEA,CAAC;MACjF,CAAC,CAAC;IACJ;IAEA,MAAM;MAAEK,SAAS;MAAEC,iBAAiB;MAAEC;IAAkB,CAAC,GAAG,IAAI,CAACC,wBAAwB,CACvFX,SAAS,EACT7C,SAAS,EACTC,WACF,CAAC;IAED,MAAMiB,YAAY,GAAG6B,QAAQ,CAACN,GAAG,CAACoC,OAAO,IAAIA,OAAO,CAAC3D,YAAY,CAAC,CAACsE,MAAM,CAACC,OAAO,CAAa;IAE9F,OAAO;MACL/B,EAAE,EAAE,SAASC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE;MACzB9D,KAAK;MACLC,GAAG;MACH8C,SAAS;MACTE,QAAQ;MACRc,aAAa,EAAEvB,QAAQ;MACvBwB,aAAa,EAAEvB,QAAQ;MACvBc,SAAS;MACTC,iBAAiB;MACjBC,iBAAiB;MACjBrC;IACF,CAAC;EACH;;EAEA;EACA,OAAemE,6BAA6BA,CAACvF,KAAe,EAAEC,GAAa,EAAgB;IACzF,MAAM8C,SAAuB,GAAG,EAAE;IAClC,MAAMP,QAAQ,GAAG3C,UAAU,CAACuD,iBAAiB,CAACpD,KAAK,EAAEC,GAAG,CAAC;;IAEzD;IACA,MAAM2F,KAAK,GAAGnB,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACE,GAAG,CAAC,CAAC,EAAEF,IAAI,CAACoB,KAAK,CAACrD,QAAQ,GAAG,GAAG,CAAC,CAAC,CAAC;IAElE,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI0C,KAAK,EAAE1C,CAAC,EAAE,EAAE;MAC/B,MAAM4C,KAAK,GAAG5C,CAAC,GAAG0C,KAAK;MACvB,MAAMG,GAAG,GAAG/F,KAAK,CAACiB,QAAQ,GAAG,CAAChB,GAAG,CAACgB,QAAQ,GAAGjB,KAAK,CAACiB,QAAQ,IAAI6E,KAAK;MACpE,MAAME,GAAG,GAAGhG,KAAK,CAACgB,SAAS,GAAG,CAACf,GAAG,CAACe,SAAS,GAAGhB,KAAK,CAACgB,SAAS,IAAI8E,KAAK;;MAEvE;MACA,MAAMG,SAAS,GAAG,MAAM,CAAC,CAAC;MAC1B,MAAMC,YAAY,GAAG,CAACzB,IAAI,CAAC0B,MAAM,CAAC,CAAC,GAAG,GAAG,IAAIF,SAAS;MACtD,MAAMG,YAAY,GAAG,CAAC3B,IAAI,CAAC0B,MAAM,CAAC,CAAC,GAAG,GAAG,IAAIF,SAAS;MAEtDlD,SAAS,CAACO,IAAI,CAAC;QACbrC,QAAQ,EAAE8E,GAAG,GAAGG,YAAY;QAC5BlF,SAAS,EAAEgF,GAAG,GAAGI;MACnB,CAAC,CAAC;IACJ;IAEA,OAAOrD,SAAS;EAClB;;EAEA;EACA,OAAe0C,0BAA0BA,CAACzF,KAAiB,EAAEC,GAAe,EAAE4E,KAAa,EAAU;IACnG,MAAMrC,QAAQ,GAAG3C,UAAU,CAACuD,iBAAiB,CAC3C;MAAEnC,QAAQ,EAAEjB,KAAK,CAACiB,QAAQ;MAAED,SAAS,EAAEhB,KAAK,CAACgB,SAAS;MAAEqC,SAAS,EAAE;IAAE,CAAC,EACtE;MAAEpC,QAAQ,EAAEhB,GAAG,CAACgB,QAAQ;MAAED,SAAS,EAAEf,GAAG,CAACe,SAAS;MAAEqC,SAAS,EAAE;IAAE,CACnE,CAAC;IAED,IAAIwB,KAAK,KAAK,CAAC,EAAE;MACf,OAAO,iBAAiB,IAAI,CAACI,YAAY,CAACjF,KAAK,EAAEC,GAAG,CAAC,QAAQwE,IAAI,CAACK,KAAK,CAACtC,QAAQ,CAAC,GAAG;IACtF,CAAC,MAAM,IAAIA,QAAQ,GAAG,EAAE,EAAE;MACxB,OAAO,gBAAgBiC,IAAI,CAACK,KAAK,CAACtC,QAAQ,CAAC,GAAG;IAChD,CAAC,MAAM;MACL,OAAO,QAAQ,IAAI,CAACyC,YAAY,CAACjF,KAAK,EAAEC,GAAG,CAAC,QAAQwE,IAAI,CAACK,KAAK,CAACtC,QAAQ,CAAC,GAAG;IAC7E;EACF;;EAEA;EACA,aAAa6D,oBAAoBA,CAC/BrG,KAAe,EACfC,GAAa,EACbC,SAAqB,EACrBC,WAAyB,EACE;IAC3B,IAAI;MACF;MACA;MACA,MAAMmG,SAAS,GAAG,MAAM,IAAI,CAACvG,eAAe,CAACC,KAAK,EAAEC,GAAG,EAAEC,SAAS,EAAEC,WAAW,CAAC;MAChF,OAAO,CAACmG,SAAS,CAAC;IACpB,CAAC,CAAC,OAAO9F,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,mCAAmC,EAAEA,KAAK,CAAC;MACzD,OAAO,EAAE;IACX;EACF;;EAEA;EACA,OAAO+F,eAAeA,CAACtE,KAAqB,EAAW;IACrD;IACA,OAAOA,KAAK,CAAC8B,aAAa,GAAG,IAAI;IAAI;IAC9B9B,KAAK,CAACgB,QAAQ,CAACuD,KAAK,CAACzB,OAAO,IAAIA,OAAO,CAACvC,QAAQ,GAAG,IAAI,CAAC,CAAC,CAAC;EACnE;;EAEA;EACA,OAAOiE,kBAAkBA,CAACxE,KAAqB,EAAuC;IACpF,MAAMO,QAAQ,GAAGP,KAAK,CAAC8B,aAAa;IACpC,MAAMR,SAAS,GAAGtB,KAAK,CAACsB,SAAS;IAEjC,IAAIf,QAAQ,GAAG,IAAI,IAAIe,SAAS,GAAG,GAAG,EAAE,OAAO,MAAM;IACrD,IAAIf,QAAQ,GAAG,IAAI,IAAIe,SAAS,GAAG,GAAG,EAAE,OAAO,UAAU;IACzD,OAAO,aAAa;EACtB;AACF;AA7WazD,cAAc,CACD0B,iBAAiB,GAAG,gDAAgD;AADjF1B,cAAc,CAEDiB,OAAO,GAAG,0CAA0C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}