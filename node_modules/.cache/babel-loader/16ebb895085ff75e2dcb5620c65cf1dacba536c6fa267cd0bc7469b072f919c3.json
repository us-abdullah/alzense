{"ast":null,"code":"import{GPSService}from'./gps';export class RoutingService{// Free tier key - replace with your own\n// Get a real walking route between two points\nstatic async getWalkingRoute(start,end,calmZones,stressZones){try{// First, get the basic route from OpenRouteService\nconst basicRoute=await this.getBasicRoute(start,end);// Then optimize it based on calm/stress zones\nconst optimizedRoute=await this.optimizeRoute(basicRoute,calmZones,stressZones);return optimizedRoute;}catch(error){console.warn('External routing APIs failed, using enhanced fallback system:',error);// Fallback to enhanced route generation\nreturn this.createFallbackRoute(start,end,calmZones,stressZones);}}// Get basic route from OpenRouteService\nstatic async getBasicRoute(start,end){try{const params=new URLSearchParams({api_key:this.API_KEY,start:\"\".concat(start.longitude,\",\").concat(start.latitude),end:\"\".concat(end.longitude,\",\").concat(end.latitude),profile:'foot-walking',format:'json',instructions:'true',geometry:'true'});const response=await fetch(\"\".concat(this.OPENROUTE_API_URL,\"?\").concat(params));if(!response.ok){throw new Error(\"HTTP error! status: \".concat(response.status));}const data=await response.json();return data;}catch(error){console.warn('OpenRouteService failed, trying GraphHopper...',error);return await this.getGraphHopperRoute(start,end);}}// Fallback to GraphHopper (free tier)\nstatic async getGraphHopperRoute(start,end){try{var _route$instructions;// GraphHopper expects multiple 'point' parameters, not an array\nconst params=new URLSearchParams();params.append('key','demo');// Free demo key\nparams.append('point',\"\".concat(start.latitude,\",\").concat(start.longitude));params.append('point',\"\".concat(end.latitude,\",\").concat(end.longitude));params.append('vehicle','foot');params.append('instructions','true');params.append('points_encoded','false');const response=await fetch(\"https://graphhopper.com/api/1/route?\".concat(params));if(!response.ok){throw new Error(\"HTTP error! status: \".concat(response.status));}const data=await response.json();// Convert GraphHopper format to our expected format\nconst route=data.paths[0];return{features:[{geometry:{coordinates:route.points.coordinates},properties:{summary:{distance:route.distance,duration:route.time/1000// Convert ms to seconds\n},instructions:((_route$instructions=route.instructions)===null||_route$instructions===void 0?void 0:_route$instructions.map(inst=>({instruction:inst.text,distance:inst.distance})))||[]}}]};}catch(error){console.warn('GraphHopper also failed, using fallback route',error);throw new Error('All routing services failed');}}// Optimize route based on calm/stress zones\nstatic async optimizeRoute(basicRoute,calmZones,stressZones){const route=basicRoute.features[0];const geometry=route.geometry.coordinates;const properties=route.properties;// Convert coordinates to our format\nconst waypoints=geometry.map(coord=>({longitude:coord[0],latitude:coord[1]}));// Create route segments\nconst segments=[];for(let i=0;i<waypoints.length-1;i++){const start=waypoints[i];const end=waypoints[i+1];const distance=GPSService.calculateDistance({latitude:start.latitude,longitude:start.longitude,timestamp:0},{latitude:end.latitude,longitude:end.longitude,timestamp:0});segments.push({start,end,distance,duration:distance/1.4// Average walking speed: 1.4 m/s\n});}// Calculate calm score and zone interactions\nconst{calmScore,avoidsStressZones,includesCalmZones}=this.analyzeRouteOptimization(waypoints,calmZones,stressZones);// Generate instructions\nconst instructions=this.generateInstructions(segments,properties.instructions||[]);return{id:\"route_\".concat(Date.now()),start:{latitude:waypoints[0].latitude,longitude:waypoints[0].longitude,timestamp:0},end:{latitude:waypoints[waypoints.length-1].latitude,longitude:waypoints[waypoints.length-1].longitude,timestamp:0},waypoints,segments,totalDistance:properties.summary.distance,totalDuration:properties.summary.duration,calmScore,avoidsStressZones,includesCalmZones,instructions};}// Analyze route optimization based on calm/stress zones\nstatic analyzeRouteOptimization(waypoints,calmZones,stressZones){let calmScore=0.5;// Base score\nconst avoidsStressZones=[];const includesCalmZones=[];// Check each waypoint against zones\nwaypoints.forEach(point=>{const pointLocation={latitude:point.latitude,longitude:point.longitude,timestamp:0};// Check stress zones\nstressZones.forEach(zone=>{if(GPSService.isWithinRadius(zone.center,pointLocation,zone.radius)){calmScore-=0.1;// Penalize for going through stress zones\nif(!avoidsStressZones.includes(zone.id)){avoidsStressZones.push(zone.id);}}});// Check calm zones\ncalmZones.forEach(zone=>{if(GPSService.isWithinRadius(zone.center,pointLocation,zone.radius)){calmScore+=0.05;// Reward for going through calm zones\nif(!includesCalmZones.includes(zone.id)){includesCalmZones.push(zone.id);}}});});// Normalize calm score to 0-1 range\ncalmScore=Math.max(0,Math.min(1,calmScore));return{calmScore,avoidsStressZones,includesCalmZones};}// Generate human-readable instructions\nstatic generateInstructions(segments,apiInstructions){const instructions=[];if(apiInstructions.length>0){// Use API instructions if available\napiInstructions.forEach((instruction,index)=>{instructions.push(\"\".concat(index+1,\". \").concat(instruction.instruction,\" (\").concat(Math.round(instruction.distance),\"m)\"));});}else{// Generate basic instructions from segments\nsegments.forEach((segment,index)=>{const direction=this.getDirection(segment.start,segment.end);instructions.push(\"\".concat(index+1,\". Walk \").concat(direction,\" for \").concat(Math.round(segment.distance),\"m\"));});}return instructions;}// Get cardinal direction between two points\nstatic getDirection(start,end){const latDiff=end.latitude-start.latitude;const lngDiff=end.longitude-start.longitude;const angle=Math.atan2(lngDiff,latDiff)*180/Math.PI;if(angle>=-22.5&&angle<22.5)return'north';if(angle>=22.5&&angle<67.5)return'northeast';if(angle>=67.5&&angle<112.5)return'east';if(angle>=112.5&&angle<157.5)return'southeast';if(angle>=157.5||angle<-157.5)return'south';if(angle>=-157.5&&angle<-112.5)return'southwest';if(angle>=-112.5&&angle<-67.5)return'west';if(angle>=-67.5&&angle<-22.5)return'northwest';return'forward';}// Create fallback route when API fails\nstatic createFallbackRoute(start,end,calmZones,stressZones){const distance=GPSService.calculateDistance(start,end);const duration=distance/1.4;// Average walking speed\n// Create a more realistic route with intermediate waypoints\nconst waypoints=this.generateIntermediateWaypoints(start,end);const segments=[];for(let i=0;i<waypoints.length-1;i++){const segmentDistance=GPSService.calculateDistance({latitude:waypoints[i].latitude,longitude:waypoints[i].longitude,timestamp:0},{latitude:waypoints[i+1].latitude,longitude:waypoints[i+1].longitude,timestamp:0});segments.push({start:waypoints[i],end:waypoints[i+1],distance:segmentDistance,duration:segmentDistance/1.4,instructions:this.generateSegmentInstruction(waypoints[i],waypoints[i+1],i)});}const{calmScore,avoidsStressZones,includesCalmZones}=this.analyzeRouteOptimization(waypoints,calmZones,stressZones);const instructions=segments.map(segment=>segment.instructions).filter(Boolean);return{id:\"route_\".concat(Date.now()),start,end,waypoints,segments,totalDistance:distance,totalDuration:duration,calmScore,avoidsStressZones,includesCalmZones,instructions};}// Generate intermediate waypoints for a more realistic route\nstatic generateIntermediateWaypoints(start,end){const waypoints=[];const distance=GPSService.calculateDistance(start,end);// More waypoints for longer distances\nconst steps=Math.max(3,Math.min(8,Math.floor(distance/200)));for(let i=0;i<=steps;i++){const ratio=i/steps;const lat=start.latitude+(end.latitude-start.latitude)*ratio;const lng=start.longitude+(end.longitude-start.longitude)*ratio;// Add slight variations to make the route more realistic\nconst variation=0.0001;// Small random variation\nconst latVariation=(Math.random()-0.5)*variation;const lngVariation=(Math.random()-0.5)*variation;waypoints.push({latitude:lat+latVariation,longitude:lng+lngVariation});}return waypoints;}// Generate instruction for a route segment\nstatic generateSegmentInstruction(start,end,index){const distance=GPSService.calculateDistance({latitude:start.latitude,longitude:start.longitude,timestamp:0},{latitude:end.latitude,longitude:end.longitude,timestamp:0});const direction=this.getDirection(start,end);const roundedDistance=Math.round(distance);if(index===0){return\"1. Start walking \".concat(direction,\" for \").concat(roundedDistance,\"m\");}else if(distance<30){return\"\".concat(index+1,\". Continue straight for \").concat(roundedDistance,\"m\");}else if(distance<100){return\"\".concat(index+1,\". Walk \").concat(direction,\" for \").concat(roundedDistance,\"m\");}else{return\"\".concat(index+1,\". Head \").concat(direction,\" for \").concat(roundedDistance,\"m\");}}// Get alternative routes (if API supports it)\nstatic async getAlternativeRoutes(start,end,calmZones,stressZones){try{// For now, return just the main route\n// In a full implementation, you could request multiple alternatives\nconst mainRoute=await this.getWalkingRoute(start,end,calmZones,stressZones);return[mainRoute];}catch(error){console.error('Error getting alternative routes:',error);return[];}}// Check if a route is suitable for walking (sidewalks, pedestrian areas, etc.)\nstatic isWalkableRoute(route){// Basic checks - in a real implementation, you'd check against road types, sidewalks, etc.\nreturn route.totalDistance<5000&&// Max 5km walk\nroute.segments.every(segment=>segment.distance<1000);// No single segment over 1km\n}// Get route difficulty level\nstatic getRouteDifficulty(route){const distance=route.totalDistance;const calmScore=route.calmScore;if(distance<1000&&calmScore>0.7)return'easy';if(distance<2500&&calmScore>0.4)return'moderate';return'challenging';}}RoutingService.OPENROUTE_API_URL='https://api.openrouteservice.org/v2/directions';RoutingService.API_KEY='5b3ce3597851110001cf6248a8b8b8b8a8b8b8b8';","map":{"version":3,"names":["GPSService","RoutingService","getWalkingRoute","start","end","calmZones","stressZones","basicRoute","getBasicRoute","optimizedRoute","optimizeRoute","error","console","warn","createFallbackRoute","params","URLSearchParams","api_key","API_KEY","concat","longitude","latitude","profile","format","instructions","geometry","response","fetch","OPENROUTE_API_URL","ok","Error","status","data","json","getGraphHopperRoute","_route$instructions","append","route","paths","features","coordinates","points","properties","summary","distance","duration","time","map","inst","instruction","text","waypoints","coord","segments","i","length","calculateDistance","timestamp","push","calmScore","avoidsStressZones","includesCalmZones","analyzeRouteOptimization","generateInstructions","id","Date","now","totalDistance","totalDuration","forEach","point","pointLocation","zone","isWithinRadius","center","radius","includes","Math","max","min","apiInstructions","index","round","segment","direction","getDirection","latDiff","lngDiff","angle","atan2","PI","generateIntermediateWaypoints","segmentDistance","generateSegmentInstruction","filter","Boolean","steps","floor","ratio","lat","lng","variation","latVariation","random","lngVariation","roundedDistance","getAlternativeRoutes","mainRoute","isWalkableRoute","every","getRouteDifficulty"],"sources":["C:/Users/usman/.cursor/alzense/src/services/routing.ts"],"sourcesContent":["import { Location, CalmZone, StressZone } from '../types';\r\nimport { GPSService } from './gps';\r\n\r\nexport interface RoutePoint {\r\n  latitude: number;\r\n  longitude: number;\r\n}\r\n\r\nexport interface RouteSegment {\r\n  start: RoutePoint;\r\n  end: RoutePoint;\r\n  distance: number; // in meters\r\n  duration: number; // in seconds\r\n  instructions?: string;\r\n}\r\n\r\nexport interface OptimizedRoute {\r\n  id: string;\r\n  start: Location;\r\n  end: Location;\r\n  waypoints: RoutePoint[];\r\n  segments: RouteSegment[];\r\n  totalDistance: number; // in meters\r\n  totalDuration: number; // in seconds\r\n  calmScore: number; // 0-1, higher is calmer\r\n  avoidsStressZones: string[];\r\n  includesCalmZones: string[];\r\n  instructions: string[];\r\n}\r\n\r\nexport class RoutingService {\r\n  private static readonly OPENROUTE_API_URL = 'https://api.openrouteservice.org/v2/directions';\r\n  private static readonly API_KEY = '5b3ce3597851110001cf6248a8b8b8b8a8b8b8b8'; // Free tier key - replace with your own\r\n\r\n  // Get a real walking route between two points\r\n  static async getWalkingRoute(\r\n    start: Location,\r\n    end: Location,\r\n    calmZones: CalmZone[],\r\n    stressZones: StressZone[]\r\n  ): Promise<OptimizedRoute> {\r\n    try {\r\n      // First, get the basic route from OpenRouteService\r\n      const basicRoute = await this.getBasicRoute(start, end);\r\n      \r\n      // Then optimize it based on calm/stress zones\r\n      const optimizedRoute = await this.optimizeRoute(basicRoute, calmZones, stressZones);\r\n      \r\n      return optimizedRoute;\r\n    } catch (error) {\r\n      console.warn('External routing APIs failed, using enhanced fallback system:', error);\r\n      // Fallback to enhanced route generation\r\n      return this.createFallbackRoute(start, end, calmZones, stressZones);\r\n    }\r\n  }\r\n\r\n  // Get basic route from OpenRouteService\r\n  private static async getBasicRoute(start: Location, end: Location): Promise<any> {\r\n    try {\r\n      const params = new URLSearchParams({\r\n        api_key: this.API_KEY,\r\n        start: `${start.longitude},${start.latitude}`,\r\n        end: `${end.longitude},${end.latitude}`,\r\n        profile: 'foot-walking',\r\n        format: 'json',\r\n        instructions: 'true',\r\n        geometry: 'true'\r\n      });\r\n\r\n      const response = await fetch(`${this.OPENROUTE_API_URL}?${params}`);\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n      \r\n      const data = await response.json();\r\n      return data;\r\n    } catch (error) {\r\n      console.warn('OpenRouteService failed, trying GraphHopper...', error);\r\n      return await this.getGraphHopperRoute(start, end);\r\n    }\r\n  }\r\n\r\n  // Fallback to GraphHopper (free tier)\r\n  private static async getGraphHopperRoute(start: Location, end: Location): Promise<any> {\r\n    try {\r\n      // GraphHopper expects multiple 'point' parameters, not an array\r\n      const params = new URLSearchParams();\r\n      params.append('key', 'demo'); // Free demo key\r\n      params.append('point', `${start.latitude},${start.longitude}`);\r\n      params.append('point', `${end.latitude},${end.longitude}`);\r\n      params.append('vehicle', 'foot');\r\n      params.append('instructions', 'true');\r\n      params.append('points_encoded', 'false');\r\n\r\n      const response = await fetch(`https://graphhopper.com/api/1/route?${params}`);\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n      \r\n      const data = await response.json();\r\n\r\n      // Convert GraphHopper format to our expected format\r\n      const route = data.paths[0];\r\n      return {\r\n        features: [{\r\n          geometry: {\r\n            coordinates: route.points.coordinates\r\n          },\r\n          properties: {\r\n            summary: {\r\n              distance: route.distance,\r\n              duration: route.time / 1000 // Convert ms to seconds\r\n            },\r\n            instructions: route.instructions?.map((inst: any) => ({\r\n              instruction: inst.text,\r\n              distance: inst.distance\r\n            })) || []\r\n          }\r\n        }]\r\n      };\r\n    } catch (error) {\r\n      console.warn('GraphHopper also failed, using fallback route', error);\r\n      throw new Error('All routing services failed');\r\n    }\r\n  }\r\n\r\n  // Optimize route based on calm/stress zones\r\n  private static async optimizeRoute(\r\n    basicRoute: any,\r\n    calmZones: CalmZone[],\r\n    stressZones: StressZone[]\r\n  ): Promise<OptimizedRoute> {\r\n    const route = basicRoute.features[0];\r\n    const geometry = route.geometry.coordinates;\r\n    const properties = route.properties;\r\n    \r\n    // Convert coordinates to our format\r\n    const waypoints: RoutePoint[] = geometry.map((coord: number[]) => ({\r\n      longitude: coord[0],\r\n      latitude: coord[1]\r\n    }));\r\n\r\n    // Create route segments\r\n    const segments: RouteSegment[] = [];\r\n    for (let i = 0; i < waypoints.length - 1; i++) {\r\n      const start = waypoints[i];\r\n      const end = waypoints[i + 1];\r\n      const distance = GPSService.calculateDistance(\r\n        { latitude: start.latitude, longitude: start.longitude, timestamp: 0 },\r\n        { latitude: end.latitude, longitude: end.longitude, timestamp: 0 }\r\n      );\r\n      \r\n      segments.push({\r\n        start,\r\n        end,\r\n        distance,\r\n        duration: distance / 1.4 // Average walking speed: 1.4 m/s\r\n      });\r\n    }\r\n\r\n    // Calculate calm score and zone interactions\r\n    const { calmScore, avoidsStressZones, includesCalmZones } = this.analyzeRouteOptimization(\r\n      waypoints,\r\n      calmZones,\r\n      stressZones\r\n    );\r\n\r\n    // Generate instructions\r\n    const instructions = this.generateInstructions(segments, properties.instructions || []);\r\n\r\n    return {\r\n      id: `route_${Date.now()}`,\r\n      start: { latitude: waypoints[0].latitude, longitude: waypoints[0].longitude, timestamp: 0 },\r\n      end: { latitude: waypoints[waypoints.length - 1].latitude, longitude: waypoints[waypoints.length - 1].longitude, timestamp: 0 },\r\n      waypoints,\r\n      segments,\r\n      totalDistance: properties.summary.distance,\r\n      totalDuration: properties.summary.duration,\r\n      calmScore,\r\n      avoidsStressZones,\r\n      includesCalmZones,\r\n      instructions\r\n    };\r\n  }\r\n\r\n  // Analyze route optimization based on calm/stress zones\r\n  private static analyzeRouteOptimization(\r\n    waypoints: RoutePoint[],\r\n    calmZones: CalmZone[],\r\n    stressZones: StressZone[]\r\n  ): { calmScore: number; avoidsStressZones: string[]; includesCalmZones: string[] } {\r\n    let calmScore = 0.5; // Base score\r\n    const avoidsStressZones: string[] = [];\r\n    const includesCalmZones: string[] = [];\r\n\r\n    // Check each waypoint against zones\r\n    waypoints.forEach(point => {\r\n      const pointLocation = { latitude: point.latitude, longitude: point.longitude, timestamp: 0 };\r\n      \r\n      // Check stress zones\r\n      stressZones.forEach(zone => {\r\n        if (GPSService.isWithinRadius(zone.center, pointLocation, zone.radius)) {\r\n          calmScore -= 0.1; // Penalize for going through stress zones\r\n          if (!avoidsStressZones.includes(zone.id)) {\r\n            avoidsStressZones.push(zone.id);\r\n          }\r\n        }\r\n      });\r\n\r\n      // Check calm zones\r\n      calmZones.forEach(zone => {\r\n        if (GPSService.isWithinRadius(zone.center, pointLocation, zone.radius)) {\r\n          calmScore += 0.05; // Reward for going through calm zones\r\n          if (!includesCalmZones.includes(zone.id)) {\r\n            includesCalmZones.push(zone.id);\r\n          }\r\n        }\r\n      });\r\n    });\r\n\r\n    // Normalize calm score to 0-1 range\r\n    calmScore = Math.max(0, Math.min(1, calmScore));\r\n\r\n    return { calmScore, avoidsStressZones, includesCalmZones };\r\n  }\r\n\r\n  // Generate human-readable instructions\r\n  private static generateInstructions(segments: RouteSegment[], apiInstructions: any[]): string[] {\r\n    const instructions: string[] = [];\r\n    \r\n    if (apiInstructions.length > 0) {\r\n      // Use API instructions if available\r\n      apiInstructions.forEach((instruction, index) => {\r\n        instructions.push(`${index + 1}. ${instruction.instruction} (${Math.round(instruction.distance)}m)`);\r\n      });\r\n    } else {\r\n      // Generate basic instructions from segments\r\n      segments.forEach((segment, index) => {\r\n        const direction = this.getDirection(segment.start, segment.end);\r\n        instructions.push(`${index + 1}. Walk ${direction} for ${Math.round(segment.distance)}m`);\r\n      });\r\n    }\r\n\r\n    return instructions;\r\n  }\r\n\r\n  // Get cardinal direction between two points\r\n  private static getDirection(start: RoutePoint, end: RoutePoint): string {\r\n    const latDiff = end.latitude - start.latitude;\r\n    const lngDiff = end.longitude - start.longitude;\r\n    const angle = Math.atan2(lngDiff, latDiff) * 180 / Math.PI;\r\n    \r\n    if (angle >= -22.5 && angle < 22.5) return 'north';\r\n    if (angle >= 22.5 && angle < 67.5) return 'northeast';\r\n    if (angle >= 67.5 && angle < 112.5) return 'east';\r\n    if (angle >= 112.5 && angle < 157.5) return 'southeast';\r\n    if (angle >= 157.5 || angle < -157.5) return 'south';\r\n    if (angle >= -157.5 && angle < -112.5) return 'southwest';\r\n    if (angle >= -112.5 && angle < -67.5) return 'west';\r\n    if (angle >= -67.5 && angle < -22.5) return 'northwest';\r\n    \r\n    return 'forward';\r\n  }\r\n\r\n  // Create fallback route when API fails\r\n  private static createFallbackRoute(\r\n    start: Location,\r\n    end: Location,\r\n    calmZones: CalmZone[],\r\n    stressZones: StressZone[]\r\n  ): OptimizedRoute {\r\n    const distance = GPSService.calculateDistance(start, end);\r\n    const duration = distance / 1.4; // Average walking speed\r\n    \r\n    // Create a more realistic route with intermediate waypoints\r\n    const waypoints: RoutePoint[] = this.generateIntermediateWaypoints(start, end);\r\n    \r\n    const segments: RouteSegment[] = [];\r\n    for (let i = 0; i < waypoints.length - 1; i++) {\r\n      const segmentDistance = GPSService.calculateDistance(\r\n        { latitude: waypoints[i].latitude, longitude: waypoints[i].longitude, timestamp: 0 },\r\n        { latitude: waypoints[i + 1].latitude, longitude: waypoints[i + 1].longitude, timestamp: 0 }\r\n      );\r\n      \r\n      segments.push({\r\n        start: waypoints[i],\r\n        end: waypoints[i + 1],\r\n        distance: segmentDistance,\r\n        duration: segmentDistance / 1.4,\r\n        instructions: this.generateSegmentInstruction(waypoints[i], waypoints[i + 1], i)\r\n      });\r\n    }\r\n\r\n    const { calmScore, avoidsStressZones, includesCalmZones } = this.analyzeRouteOptimization(\r\n      waypoints,\r\n      calmZones,\r\n      stressZones\r\n    );\r\n\r\n    const instructions = segments.map(segment => segment.instructions).filter(Boolean) as string[];\r\n\r\n    return {\r\n      id: `route_${Date.now()}`,\r\n      start,\r\n      end,\r\n      waypoints,\r\n      segments,\r\n      totalDistance: distance,\r\n      totalDuration: duration,\r\n      calmScore,\r\n      avoidsStressZones,\r\n      includesCalmZones,\r\n      instructions\r\n    };\r\n  }\r\n\r\n  // Generate intermediate waypoints for a more realistic route\r\n  private static generateIntermediateWaypoints(start: Location, end: Location): RoutePoint[] {\r\n    const waypoints: RoutePoint[] = [];\r\n    const distance = GPSService.calculateDistance(start, end);\r\n    \r\n    // More waypoints for longer distances\r\n    const steps = Math.max(3, Math.min(8, Math.floor(distance / 200)));\r\n    \r\n    for (let i = 0; i <= steps; i++) {\r\n      const ratio = i / steps;\r\n      const lat = start.latitude + (end.latitude - start.latitude) * ratio;\r\n      const lng = start.longitude + (end.longitude - start.longitude) * ratio;\r\n      \r\n      // Add slight variations to make the route more realistic\r\n      const variation = 0.0001; // Small random variation\r\n      const latVariation = (Math.random() - 0.5) * variation;\r\n      const lngVariation = (Math.random() - 0.5) * variation;\r\n      \r\n      waypoints.push({ \r\n        latitude: lat + latVariation, \r\n        longitude: lng + lngVariation \r\n      });\r\n    }\r\n    \r\n    return waypoints;\r\n  }\r\n\r\n  // Generate instruction for a route segment\r\n  private static generateSegmentInstruction(start: RoutePoint, end: RoutePoint, index: number): string {\r\n    const distance = GPSService.calculateDistance(\r\n      { latitude: start.latitude, longitude: start.longitude, timestamp: 0 },\r\n      { latitude: end.latitude, longitude: end.longitude, timestamp: 0 }\r\n    );\r\n    \r\n    const direction = this.getDirection(start, end);\r\n    const roundedDistance = Math.round(distance);\r\n    \r\n    if (index === 0) {\r\n      return `1. Start walking ${direction} for ${roundedDistance}m`;\r\n    } else if (distance < 30) {\r\n      return `${index + 1}. Continue straight for ${roundedDistance}m`;\r\n    } else if (distance < 100) {\r\n      return `${index + 1}. Walk ${direction} for ${roundedDistance}m`;\r\n    } else {\r\n      return `${index + 1}. Head ${direction} for ${roundedDistance}m`;\r\n    }\r\n  }\r\n\r\n  // Get alternative routes (if API supports it)\r\n  static async getAlternativeRoutes(\r\n    start: Location,\r\n    end: Location,\r\n    calmZones: CalmZone[],\r\n    stressZones: StressZone[]\r\n  ): Promise<OptimizedRoute[]> {\r\n    try {\r\n      // For now, return just the main route\r\n      // In a full implementation, you could request multiple alternatives\r\n      const mainRoute = await this.getWalkingRoute(start, end, calmZones, stressZones);\r\n      return [mainRoute];\r\n    } catch (error) {\r\n      console.error('Error getting alternative routes:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  // Check if a route is suitable for walking (sidewalks, pedestrian areas, etc.)\r\n  static isWalkableRoute(route: OptimizedRoute): boolean {\r\n    // Basic checks - in a real implementation, you'd check against road types, sidewalks, etc.\r\n    return route.totalDistance < 5000 && // Max 5km walk\r\n           route.segments.every(segment => segment.distance < 1000); // No single segment over 1km\r\n  }\r\n\r\n  // Get route difficulty level\r\n  static getRouteDifficulty(route: OptimizedRoute): 'easy' | 'moderate' | 'challenging' {\r\n    const distance = route.totalDistance;\r\n    const calmScore = route.calmScore;\r\n    \r\n    if (distance < 1000 && calmScore > 0.7) return 'easy';\r\n    if (distance < 2500 && calmScore > 0.4) return 'moderate';\r\n    return 'challenging';\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}