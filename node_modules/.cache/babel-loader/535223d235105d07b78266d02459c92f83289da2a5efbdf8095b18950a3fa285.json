{"ast":null,"code":"import axios from 'axios';\nimport { GPSService } from './gps';\nexport class RoutingService {\n  // Free tier key - replace with your own\n\n  // Get a real walking route between two points\n  static async getWalkingRoute(start, end, calmZones, stressZones) {\n    try {\n      // First, get the basic route from OpenRouteService\n      const basicRoute = await this.getBasicRoute(start, end);\n\n      // Then optimize it based on calm/stress zones\n      const optimizedRoute = await this.optimizeRoute(basicRoute, calmZones, stressZones);\n      return optimizedRoute;\n    } catch (error) {\n      console.error('Routing error:', error);\n      // Fallback to simple straight-line route\n      return this.createFallbackRoute(start, end, calmZones, stressZones);\n    }\n  }\n\n  // Get basic route from OpenRouteService\n  static async getBasicRoute(start, end) {\n    const response = await axios.get(this.OPENROUTE_API_URL, {\n      params: {\n        api_key: this.API_KEY,\n        start: `${start.longitude},${start.latitude}`,\n        end: `${end.longitude},${end.latitude}`,\n        profile: 'foot-walking',\n        format: 'json',\n        instructions: true,\n        geometry: true\n      }\n    });\n    return response.data;\n  }\n\n  // Optimize route based on calm/stress zones\n  static async optimizeRoute(basicRoute, calmZones, stressZones) {\n    const route = basicRoute.features[0];\n    const geometry = route.geometry.coordinates;\n    const properties = route.properties;\n\n    // Convert coordinates to our format\n    const waypoints = geometry.map(coord => ({\n      longitude: coord[0],\n      latitude: coord[1]\n    }));\n\n    // Create route segments\n    const segments = [];\n    for (let i = 0; i < waypoints.length - 1; i++) {\n      const start = waypoints[i];\n      const end = waypoints[i + 1];\n      const distance = GPSService.calculateDistance({\n        latitude: start.latitude,\n        longitude: start.longitude,\n        timestamp: 0\n      }, {\n        latitude: end.latitude,\n        longitude: end.longitude,\n        timestamp: 0\n      });\n      segments.push({\n        start,\n        end,\n        distance,\n        duration: distance / 1.4 // Average walking speed: 1.4 m/s\n      });\n    }\n\n    // Calculate calm score and zone interactions\n    const {\n      calmScore,\n      avoidsStressZones,\n      includesCalmZones\n    } = this.analyzeRouteOptimization(waypoints, calmZones, stressZones);\n\n    // Generate instructions\n    const instructions = this.generateInstructions(segments, properties.instructions || []);\n    return {\n      id: `route_${Date.now()}`,\n      start: {\n        latitude: waypoints[0].latitude,\n        longitude: waypoints[0].longitude,\n        timestamp: 0\n      },\n      end: {\n        latitude: waypoints[waypoints.length - 1].latitude,\n        longitude: waypoints[waypoints.length - 1].longitude,\n        timestamp: 0\n      },\n      waypoints,\n      segments,\n      totalDistance: properties.summary.distance,\n      totalDuration: properties.summary.duration,\n      calmScore,\n      avoidsStressZones,\n      includesCalmZones,\n      instructions\n    };\n  }\n\n  // Analyze route optimization based on calm/stress zones\n  static analyzeRouteOptimization(waypoints, calmZones, stressZones) {\n    let calmScore = 0.5; // Base score\n    const avoidsStressZones = [];\n    const includesCalmZones = [];\n\n    // Check each waypoint against zones\n    waypoints.forEach(point => {\n      const pointLocation = {\n        latitude: point.latitude,\n        longitude: point.longitude,\n        timestamp: 0\n      };\n\n      // Check stress zones\n      stressZones.forEach(zone => {\n        if (GPSService.isWithinRadius(zone.center, pointLocation, zone.radius)) {\n          calmScore -= 0.1; // Penalize for going through stress zones\n          if (!avoidsStressZones.includes(zone.id)) {\n            avoidsStressZones.push(zone.id);\n          }\n        }\n      });\n\n      // Check calm zones\n      calmZones.forEach(zone => {\n        if (GPSService.isWithinRadius(zone.center, pointLocation, zone.radius)) {\n          calmScore += 0.05; // Reward for going through calm zones\n          if (!includesCalmZones.includes(zone.id)) {\n            includesCalmZones.push(zone.id);\n          }\n        }\n      });\n    });\n\n    // Normalize calm score to 0-1 range\n    calmScore = Math.max(0, Math.min(1, calmScore));\n    return {\n      calmScore,\n      avoidsStressZones,\n      includesCalmZones\n    };\n  }\n\n  // Generate human-readable instructions\n  static generateInstructions(segments, apiInstructions) {\n    const instructions = [];\n    if (apiInstructions.length > 0) {\n      // Use API instructions if available\n      apiInstructions.forEach((instruction, index) => {\n        instructions.push(`${index + 1}. ${instruction.instruction} (${Math.round(instruction.distance)}m)`);\n      });\n    } else {\n      // Generate basic instructions from segments\n      segments.forEach((segment, index) => {\n        const direction = this.getDirection(segment.start, segment.end);\n        instructions.push(`${index + 1}. Walk ${direction} for ${Math.round(segment.distance)}m`);\n      });\n    }\n    return instructions;\n  }\n\n  // Get cardinal direction between two points\n  static getDirection(start, end) {\n    const latDiff = end.latitude - start.latitude;\n    const lngDiff = end.longitude - start.longitude;\n    const angle = Math.atan2(lngDiff, latDiff) * 180 / Math.PI;\n    if (angle >= -22.5 && angle < 22.5) return 'north';\n    if (angle >= 22.5 && angle < 67.5) return 'northeast';\n    if (angle >= 67.5 && angle < 112.5) return 'east';\n    if (angle >= 112.5 && angle < 157.5) return 'southeast';\n    if (angle >= 157.5 || angle < -157.5) return 'south';\n    if (angle >= -157.5 && angle < -112.5) return 'southwest';\n    if (angle >= -112.5 && angle < -67.5) return 'west';\n    if (angle >= -67.5 && angle < -22.5) return 'northwest';\n    return 'forward';\n  }\n\n  // Create fallback route when API fails\n  static createFallbackRoute(start, end, calmZones, stressZones) {\n    const distance = GPSService.calculateDistance(start, end);\n    const duration = distance / 1.4; // Average walking speed\n\n    // Simple straight-line route\n    const waypoints = [{\n      latitude: start.latitude,\n      longitude: start.longitude\n    }, {\n      latitude: end.latitude,\n      longitude: end.longitude\n    }];\n    const segments = [{\n      start: waypoints[0],\n      end: waypoints[1],\n      distance,\n      duration,\n      instructions: `Walk straight for ${Math.round(distance)}m`\n    }];\n    const {\n      calmScore,\n      avoidsStressZones,\n      includesCalmZones\n    } = this.analyzeRouteOptimization(waypoints, calmZones, stressZones);\n    return {\n      id: `route_${Date.now()}`,\n      start,\n      end,\n      waypoints,\n      segments,\n      totalDistance: distance,\n      totalDuration: duration,\n      calmScore,\n      avoidsStressZones,\n      includesCalmZones,\n      instructions: [`Walk straight for ${Math.round(distance)}m`]\n    };\n  }\n\n  // Get alternative routes (if API supports it)\n  static async getAlternativeRoutes(start, end, calmZones, stressZones) {\n    try {\n      // For now, return just the main route\n      // In a full implementation, you could request multiple alternatives\n      const mainRoute = await this.getWalkingRoute(start, end, calmZones, stressZones);\n      return [mainRoute];\n    } catch (error) {\n      console.error('Error getting alternative routes:', error);\n      return [];\n    }\n  }\n\n  // Check if a route is suitable for walking (sidewalks, pedestrian areas, etc.)\n  static isWalkableRoute(route) {\n    // Basic checks - in a real implementation, you'd check against road types, sidewalks, etc.\n    return route.totalDistance < 5000 &&\n    // Max 5km walk\n    route.segments.every(segment => segment.distance < 1000); // No single segment over 1km\n  }\n\n  // Get route difficulty level\n  static getRouteDifficulty(route) {\n    const distance = route.totalDistance;\n    const calmScore = route.calmScore;\n    if (distance < 1000 && calmScore > 0.7) return 'easy';\n    if (distance < 2500 && calmScore > 0.4) return 'moderate';\n    return 'challenging';\n  }\n}\nRoutingService.OPENROUTE_API_URL = 'https://api.openrouteservice.org/v2/directions';\nRoutingService.API_KEY = '5b3ce3597851110001cf6248a8b8b8b8a8b8b8b8';","map":{"version":3,"names":["axios","GPSService","RoutingService","getWalkingRoute","start","end","calmZones","stressZones","basicRoute","getBasicRoute","optimizedRoute","optimizeRoute","error","console","createFallbackRoute","response","get","OPENROUTE_API_URL","params","api_key","API_KEY","longitude","latitude","profile","format","instructions","geometry","data","route","features","coordinates","properties","waypoints","map","coord","segments","i","length","distance","calculateDistance","timestamp","push","duration","calmScore","avoidsStressZones","includesCalmZones","analyzeRouteOptimization","generateInstructions","id","Date","now","totalDistance","summary","totalDuration","forEach","point","pointLocation","zone","isWithinRadius","center","radius","includes","Math","max","min","apiInstructions","instruction","index","round","segment","direction","getDirection","latDiff","lngDiff","angle","atan2","PI","getAlternativeRoutes","mainRoute","isWalkableRoute","every","getRouteDifficulty"],"sources":["C:/Users/usman/.cursor/alzense/src/services/routing.ts"],"sourcesContent":["import axios from 'axios';\r\nimport { Location, CalmZone, StressZone } from '../types';\r\nimport { GPSService } from './gps';\r\n\r\nexport interface RoutePoint {\r\n  latitude: number;\r\n  longitude: number;\r\n}\r\n\r\nexport interface RouteSegment {\r\n  start: RoutePoint;\r\n  end: RoutePoint;\r\n  distance: number; // in meters\r\n  duration: number; // in seconds\r\n  instructions?: string;\r\n}\r\n\r\nexport interface OptimizedRoute {\r\n  id: string;\r\n  start: Location;\r\n  end: Location;\r\n  waypoints: RoutePoint[];\r\n  segments: RouteSegment[];\r\n  totalDistance: number; // in meters\r\n  totalDuration: number; // in seconds\r\n  calmScore: number; // 0-1, higher is calmer\r\n  avoidsStressZones: string[];\r\n  includesCalmZones: string[];\r\n  instructions: string[];\r\n}\r\n\r\nexport class RoutingService {\r\n  private static readonly OPENROUTE_API_URL = 'https://api.openrouteservice.org/v2/directions';\r\n  private static readonly API_KEY = '5b3ce3597851110001cf6248a8b8b8b8a8b8b8b8'; // Free tier key - replace with your own\r\n\r\n  // Get a real walking route between two points\r\n  static async getWalkingRoute(\r\n    start: Location,\r\n    end: Location,\r\n    calmZones: CalmZone[],\r\n    stressZones: StressZone[]\r\n  ): Promise<OptimizedRoute> {\r\n    try {\r\n      // First, get the basic route from OpenRouteService\r\n      const basicRoute = await this.getBasicRoute(start, end);\r\n      \r\n      // Then optimize it based on calm/stress zones\r\n      const optimizedRoute = await this.optimizeRoute(basicRoute, calmZones, stressZones);\r\n      \r\n      return optimizedRoute;\r\n    } catch (error) {\r\n      console.error('Routing error:', error);\r\n      // Fallback to simple straight-line route\r\n      return this.createFallbackRoute(start, end, calmZones, stressZones);\r\n    }\r\n  }\r\n\r\n  // Get basic route from OpenRouteService\r\n  private static async getBasicRoute(start: Location, end: Location): Promise<any> {\r\n    const response = await axios.get(this.OPENROUTE_API_URL, {\r\n      params: {\r\n        api_key: this.API_KEY,\r\n        start: `${start.longitude},${start.latitude}`,\r\n        end: `${end.longitude},${end.latitude}`,\r\n        profile: 'foot-walking',\r\n        format: 'json',\r\n        instructions: true,\r\n        geometry: true\r\n      }\r\n    });\r\n\r\n    return response.data;\r\n  }\r\n\r\n  // Optimize route based on calm/stress zones\r\n  private static async optimizeRoute(\r\n    basicRoute: any,\r\n    calmZones: CalmZone[],\r\n    stressZones: StressZone[]\r\n  ): Promise<OptimizedRoute> {\r\n    const route = basicRoute.features[0];\r\n    const geometry = route.geometry.coordinates;\r\n    const properties = route.properties;\r\n    \r\n    // Convert coordinates to our format\r\n    const waypoints: RoutePoint[] = geometry.map((coord: number[]) => ({\r\n      longitude: coord[0],\r\n      latitude: coord[1]\r\n    }));\r\n\r\n    // Create route segments\r\n    const segments: RouteSegment[] = [];\r\n    for (let i = 0; i < waypoints.length - 1; i++) {\r\n      const start = waypoints[i];\r\n      const end = waypoints[i + 1];\r\n      const distance = GPSService.calculateDistance(\r\n        { latitude: start.latitude, longitude: start.longitude, timestamp: 0 },\r\n        { latitude: end.latitude, longitude: end.longitude, timestamp: 0 }\r\n      );\r\n      \r\n      segments.push({\r\n        start,\r\n        end,\r\n        distance,\r\n        duration: distance / 1.4 // Average walking speed: 1.4 m/s\r\n      });\r\n    }\r\n\r\n    // Calculate calm score and zone interactions\r\n    const { calmScore, avoidsStressZones, includesCalmZones } = this.analyzeRouteOptimization(\r\n      waypoints,\r\n      calmZones,\r\n      stressZones\r\n    );\r\n\r\n    // Generate instructions\r\n    const instructions = this.generateInstructions(segments, properties.instructions || []);\r\n\r\n    return {\r\n      id: `route_${Date.now()}`,\r\n      start: { latitude: waypoints[0].latitude, longitude: waypoints[0].longitude, timestamp: 0 },\r\n      end: { latitude: waypoints[waypoints.length - 1].latitude, longitude: waypoints[waypoints.length - 1].longitude, timestamp: 0 },\r\n      waypoints,\r\n      segments,\r\n      totalDistance: properties.summary.distance,\r\n      totalDuration: properties.summary.duration,\r\n      calmScore,\r\n      avoidsStressZones,\r\n      includesCalmZones,\r\n      instructions\r\n    };\r\n  }\r\n\r\n  // Analyze route optimization based on calm/stress zones\r\n  private static analyzeRouteOptimization(\r\n    waypoints: RoutePoint[],\r\n    calmZones: CalmZone[],\r\n    stressZones: StressZone[]\r\n  ): { calmScore: number; avoidsStressZones: string[]; includesCalmZones: string[] } {\r\n    let calmScore = 0.5; // Base score\r\n    const avoidsStressZones: string[] = [];\r\n    const includesCalmZones: string[] = [];\r\n\r\n    // Check each waypoint against zones\r\n    waypoints.forEach(point => {\r\n      const pointLocation = { latitude: point.latitude, longitude: point.longitude, timestamp: 0 };\r\n      \r\n      // Check stress zones\r\n      stressZones.forEach(zone => {\r\n        if (GPSService.isWithinRadius(zone.center, pointLocation, zone.radius)) {\r\n          calmScore -= 0.1; // Penalize for going through stress zones\r\n          if (!avoidsStressZones.includes(zone.id)) {\r\n            avoidsStressZones.push(zone.id);\r\n          }\r\n        }\r\n      });\r\n\r\n      // Check calm zones\r\n      calmZones.forEach(zone => {\r\n        if (GPSService.isWithinRadius(zone.center, pointLocation, zone.radius)) {\r\n          calmScore += 0.05; // Reward for going through calm zones\r\n          if (!includesCalmZones.includes(zone.id)) {\r\n            includesCalmZones.push(zone.id);\r\n          }\r\n        }\r\n      });\r\n    });\r\n\r\n    // Normalize calm score to 0-1 range\r\n    calmScore = Math.max(0, Math.min(1, calmScore));\r\n\r\n    return { calmScore, avoidsStressZones, includesCalmZones };\r\n  }\r\n\r\n  // Generate human-readable instructions\r\n  private static generateInstructions(segments: RouteSegment[], apiInstructions: any[]): string[] {\r\n    const instructions: string[] = [];\r\n    \r\n    if (apiInstructions.length > 0) {\r\n      // Use API instructions if available\r\n      apiInstructions.forEach((instruction, index) => {\r\n        instructions.push(`${index + 1}. ${instruction.instruction} (${Math.round(instruction.distance)}m)`);\r\n      });\r\n    } else {\r\n      // Generate basic instructions from segments\r\n      segments.forEach((segment, index) => {\r\n        const direction = this.getDirection(segment.start, segment.end);\r\n        instructions.push(`${index + 1}. Walk ${direction} for ${Math.round(segment.distance)}m`);\r\n      });\r\n    }\r\n\r\n    return instructions;\r\n  }\r\n\r\n  // Get cardinal direction between two points\r\n  private static getDirection(start: RoutePoint, end: RoutePoint): string {\r\n    const latDiff = end.latitude - start.latitude;\r\n    const lngDiff = end.longitude - start.longitude;\r\n    const angle = Math.atan2(lngDiff, latDiff) * 180 / Math.PI;\r\n    \r\n    if (angle >= -22.5 && angle < 22.5) return 'north';\r\n    if (angle >= 22.5 && angle < 67.5) return 'northeast';\r\n    if (angle >= 67.5 && angle < 112.5) return 'east';\r\n    if (angle >= 112.5 && angle < 157.5) return 'southeast';\r\n    if (angle >= 157.5 || angle < -157.5) return 'south';\r\n    if (angle >= -157.5 && angle < -112.5) return 'southwest';\r\n    if (angle >= -112.5 && angle < -67.5) return 'west';\r\n    if (angle >= -67.5 && angle < -22.5) return 'northwest';\r\n    \r\n    return 'forward';\r\n  }\r\n\r\n  // Create fallback route when API fails\r\n  private static createFallbackRoute(\r\n    start: Location,\r\n    end: Location,\r\n    calmZones: CalmZone[],\r\n    stressZones: StressZone[]\r\n  ): OptimizedRoute {\r\n    const distance = GPSService.calculateDistance(start, end);\r\n    const duration = distance / 1.4; // Average walking speed\r\n    \r\n    // Simple straight-line route\r\n    const waypoints: RoutePoint[] = [\r\n      { latitude: start.latitude, longitude: start.longitude },\r\n      { latitude: end.latitude, longitude: end.longitude }\r\n    ];\r\n\r\n    const segments: RouteSegment[] = [{\r\n      start: waypoints[0],\r\n      end: waypoints[1],\r\n      distance,\r\n      duration,\r\n      instructions: `Walk straight for ${Math.round(distance)}m`\r\n    }];\r\n\r\n    const { calmScore, avoidsStressZones, includesCalmZones } = this.analyzeRouteOptimization(\r\n      waypoints,\r\n      calmZones,\r\n      stressZones\r\n    );\r\n\r\n    return {\r\n      id: `route_${Date.now()}`,\r\n      start,\r\n      end,\r\n      waypoints,\r\n      segments,\r\n      totalDistance: distance,\r\n      totalDuration: duration,\r\n      calmScore,\r\n      avoidsStressZones,\r\n      includesCalmZones,\r\n      instructions: [`Walk straight for ${Math.round(distance)}m`]\r\n    };\r\n  }\r\n\r\n  // Get alternative routes (if API supports it)\r\n  static async getAlternativeRoutes(\r\n    start: Location,\r\n    end: Location,\r\n    calmZones: CalmZone[],\r\n    stressZones: StressZone[]\r\n  ): Promise<OptimizedRoute[]> {\r\n    try {\r\n      // For now, return just the main route\r\n      // In a full implementation, you could request multiple alternatives\r\n      const mainRoute = await this.getWalkingRoute(start, end, calmZones, stressZones);\r\n      return [mainRoute];\r\n    } catch (error) {\r\n      console.error('Error getting alternative routes:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  // Check if a route is suitable for walking (sidewalks, pedestrian areas, etc.)\r\n  static isWalkableRoute(route: OptimizedRoute): boolean {\r\n    // Basic checks - in a real implementation, you'd check against road types, sidewalks, etc.\r\n    return route.totalDistance < 5000 && // Max 5km walk\r\n           route.segments.every(segment => segment.distance < 1000); // No single segment over 1km\r\n  }\r\n\r\n  // Get route difficulty level\r\n  static getRouteDifficulty(route: OptimizedRoute): 'easy' | 'moderate' | 'challenging' {\r\n    const distance = route.totalDistance;\r\n    const calmScore = route.calmScore;\r\n    \r\n    if (distance < 1000 && calmScore > 0.7) return 'easy';\r\n    if (distance < 2500 && calmScore > 0.4) return 'moderate';\r\n    return 'challenging';\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}