{"ast":null,"code":"import{GPSService}from'./gps';export class InsightsService{// Generate insights for a walk session\nstatic generateSessionInsights(session){const{moodEntries,stressCount,calmCount}=session;if(moodEntries.length===0){return\"No mood data recorded for this walk.\";}const totalEntries=moodEntries.length;const stressPercentage=Math.round(stressCount/totalEntries*100);const calmPercentage=Math.round(calmCount/totalEntries*100);let insights=[];// Overall mood summary\nif(stressCount>calmCount){insights.push(\"The walk had more stressful moments (\".concat(stressPercentage,\"%) than calm ones.\"));}else if(calmCount>stressCount){insights.push(\"The walk was mostly peaceful (\".concat(calmPercentage,\"% calm moments).\"));}else{insights.push(\"The walk had a balanced mix of emotions.\");}// Noise correlation\nconst highNoiseEntries=moodEntries.filter(entry=>entry.noiseLevel>60);const highNoiseStressed=highNoiseEntries.filter(entry=>entry.mood==='stressed');if(highNoiseStressed.length>0){const noiseStressCorrelation=Math.round(highNoiseStressed.length/highNoiseEntries.length*100);insights.push(\"High noise levels (\".concat(highNoiseStressed.length,\" instances) often correlated with stress (\").concat(noiseStressCorrelation,\"% of the time).\"));}// Time-based patterns\nconst morningEntries=moodEntries.filter(entry=>{const hour=new Date(entry.timestamp).getHours();return hour>=6&&hour<12;});const afternoonEntries=moodEntries.filter(entry=>{const hour=new Date(entry.timestamp).getHours();return hour>=12&&hour<18;});const eveningEntries=moodEntries.filter(entry=>{const hour=new Date(entry.timestamp).getHours();return hour>=18||hour<6;});const timeInsights=this.analyzeTimePatterns(morningEntries,afternoonEntries,eveningEntries);if(timeInsights){insights.push(timeInsights);}// Location clustering\nconst locationInsights=this.analyzeLocationPatterns(moodEntries);if(locationInsights){insights.push(locationInsights);}return insights.join(' ');}// Analyze time-based mood patterns\nstatic analyzeTimePatterns(morning,afternoon,evening){const periods=[{name:'morning',entries:morning},{name:'afternoon',entries:afternoon},{name:'evening',entries:evening}];const periodStressRates=periods.map(period=>({name:period.name,stressRate:period.entries.length>0?period.entries.filter(e=>e.mood==='stressed').length/period.entries.length:0}));const bestPeriod=periodStressRates.reduce((best,current)=>current.stressRate<best.stressRate?current:best);const worstPeriod=periodStressRates.reduce((worst,current)=>current.stressRate>worst.stressRate?current:worst);if(bestPeriod.stressRate<0.2&&worstPeriod.stressRate>0.4){return\"Consider walking more in the \".concat(bestPeriod.name,\" when stress levels are lower.\");}return null;}// Analyze location-based patterns\nstatic analyzeLocationPatterns(entries){if(entries.length<3)return null;// Group nearby entries (within 50 meters)\nconst clusters=this.clusterNearbyEntries(entries,50);const clusterMoods=clusters.map(cluster=>({center:cluster.center,entries:cluster.entries,stressRate:cluster.entries.filter(e=>e.mood==='stressed').length/cluster.entries.length,calmRate:cluster.entries.filter(e=>e.mood==='calm').length/cluster.entries.length}));const stressClusters=clusterMoods.filter(c=>c.stressRate>0.6);const calmClusters=clusterMoods.filter(c=>c.calmRate>0.6);if(stressClusters.length>0){return\"Some areas consistently triggered stress. Consider avoiding these locations.\";}if(calmClusters.length>0){return\"Some areas consistently provided calm moments. These might be good rest spots.\";}return null;}// Cluster nearby mood entries\nstatic clusterNearbyEntries(entries,radiusMeters){const clusters=[];const processed=new Set();entries.forEach(entry=>{if(processed.has(entry.id))return;const cluster={center:entry.location,entries:[entry]};// Find nearby entries\nentries.forEach(otherEntry=>{if(otherEntry.id===entry.id||processed.has(otherEntry.id))return;if(GPSService.calculateDistance(entry.location,otherEntry.location)<=radiusMeters){cluster.entries.push(otherEntry);processed.add(otherEntry.id);}});processed.add(entry.id);clusters.push(cluster);});return clusters;}// Update calm and stress zones based on session data\nstatic updateZonesFromSession(session,existingCalmZones,existingStressZones){const calmZones=[...existingCalmZones];const stressZones=[...existingStressZones];// Group entries by location clusters\nconst clusters=this.clusterNearbyEntries(session.moodEntries,30);clusters.forEach(cluster=>{const stressRate=cluster.entries.filter(e=>e.mood==='stressed').length/cluster.entries.length;const calmRate=cluster.entries.filter(e=>e.mood==='calm').length/cluster.entries.length;if(stressRate>0.6&&cluster.entries.length>=2){// This is a stress zone\nconst existingZone=stressZones.find(zone=>GPSService.calculateDistance(zone.center,cluster.center)<50);if(existingZone){existingZone.stressCount+=cluster.entries.length;existingZone.stressScore=Math.min(1,existingZone.stressScore+0.1);existingZone.lastStressed=Math.max(existingZone.lastStressed,Math.max(...cluster.entries.map(e=>e.timestamp)));}else{stressZones.push({id:\"stress_\".concat(Date.now(),\"_\").concat(Math.random().toString(36).substr(2,9)),center:cluster.center,radius:30,stressScore:stressRate,stressCount:cluster.entries.length,lastStressed:Math.max(...cluster.entries.map(e=>e.timestamp))});}}else if(calmRate>0.6&&cluster.entries.length>=2){// This is a calm zone\nconst existingZone=calmZones.find(zone=>GPSService.calculateDistance(zone.center,cluster.center)<50);if(existingZone){existingZone.visitCount+=cluster.entries.length;existingZone.calmScore=Math.min(1,existingZone.calmScore+0.1);existingZone.lastVisited=Math.max(existingZone.lastVisited,Math.max(...cluster.entries.map(e=>e.timestamp)));}else{calmZones.push({id:\"calm_\".concat(Date.now(),\"_\").concat(Math.random().toString(36).substr(2,9)),center:cluster.center,radius:30,calmScore:calmRate,visitCount:cluster.entries.length,lastVisited:Math.max(...cluster.entries.map(e=>e.timestamp))});}}});return{calmZones,stressZones};}// Generate route suggestions\nstatic generateRouteSuggestion(start,end,calmZones,stressZones){// Simple route suggestion algorithm\n// In a real implementation, this would use a proper routing service\nconst waypoints=[];let calmScore=0.5;// Base score\n// Try to include calm zones along the route\nconst nearbyCalmZones=calmZones.filter(zone=>{const distToStart=GPSService.calculateDistance(start,zone.center);const distToEnd=GPSService.calculateDistance(end,zone.center);return distToStart<200&&distToEnd<200;});if(nearbyCalmZones.length>0){const bestCalmZone=nearbyCalmZones.reduce((best,current)=>current.calmScore>best.calmScore?current:best);waypoints.push(bestCalmZone.center);calmScore+=bestCalmZone.calmScore*0.3;}// Avoid stress zones\nconst nearbyStressZones=stressZones.filter(zone=>{const distToStart=GPSService.calculateDistance(start,zone.center);const distToEnd=GPSService.calculateDistance(end,zone.center);return distToStart<200&&distToEnd<200;});calmScore-=nearbyStressZones.length*0.2;// Calculate estimated duration (rough approximation)\nconst totalDistance=GPSService.calculateDistance(start,end);const estimatedDuration=Math.round(totalDistance/1000*12);// ~12 min per km walking\nreturn{id:\"route_\".concat(Date.now()),start,end,waypoints,calmScore:Math.max(0,Math.min(1,calmScore)),estimatedDuration,avoidsStressZones:nearbyStressZones.map(zone=>zone.id),includesCalmZones:nearbyCalmZones.map(zone=>zone.id)};}}","map":{"version":3,"names":["GPSService","InsightsService","generateSessionInsights","session","moodEntries","stressCount","calmCount","length","totalEntries","stressPercentage","Math","round","calmPercentage","insights","push","concat","highNoiseEntries","filter","entry","noiseLevel","highNoiseStressed","mood","noiseStressCorrelation","morningEntries","hour","Date","timestamp","getHours","afternoonEntries","eveningEntries","timeInsights","analyzeTimePatterns","locationInsights","analyzeLocationPatterns","join","morning","afternoon","evening","periods","name","entries","periodStressRates","map","period","stressRate","e","bestPeriod","reduce","best","current","worstPeriod","worst","clusters","clusterNearbyEntries","clusterMoods","cluster","center","calmRate","stressClusters","c","calmClusters","radiusMeters","processed","Set","forEach","has","id","location","otherEntry","calculateDistance","add","updateZonesFromSession","existingCalmZones","existingStressZones","calmZones","stressZones","existingZone","find","zone","stressScore","min","lastStressed","max","now","random","toString","substr","radius","visitCount","calmScore","lastVisited","generateRouteSuggestion","start","end","waypoints","nearbyCalmZones","distToStart","distToEnd","bestCalmZone","nearbyStressZones","totalDistance","estimatedDuration","avoidsStressZones","includesCalmZones"],"sources":["C:/Users/usman/.cursor/alzense/src/services/insights.ts"],"sourcesContent":["import { WalkSession, MoodEntry, CalmZone, StressZone, Location } from '../types';\r\nimport { GPSService } from './gps';\r\n\r\nexport class InsightsService {\r\n  // Generate insights for a walk session\r\n  static generateSessionInsights(session: WalkSession): string {\r\n    const { moodEntries, stressCount, calmCount } = session;\r\n    \r\n    if (moodEntries.length === 0) {\r\n      return \"No mood data recorded for this walk.\";\r\n    }\r\n\r\n    const totalEntries = moodEntries.length;\r\n    const stressPercentage = Math.round((stressCount / totalEntries) * 100);\r\n    const calmPercentage = Math.round((calmCount / totalEntries) * 100);\r\n    \r\n    let insights = [];\r\n    \r\n    // Overall mood summary\r\n    if (stressCount > calmCount) {\r\n      insights.push(`The walk had more stressful moments (${stressPercentage}%) than calm ones.`);\r\n    } else if (calmCount > stressCount) {\r\n      insights.push(`The walk was mostly peaceful (${calmPercentage}% calm moments).`);\r\n    } else {\r\n      insights.push(`The walk had a balanced mix of emotions.`);\r\n    }\r\n\r\n    // Noise correlation\r\n    const highNoiseEntries = moodEntries.filter(entry => entry.noiseLevel > 60);\r\n    const highNoiseStressed = highNoiseEntries.filter(entry => entry.mood === 'stressed');\r\n    \r\n    if (highNoiseStressed.length > 0) {\r\n      const noiseStressCorrelation = Math.round((highNoiseStressed.length / highNoiseEntries.length) * 100);\r\n      insights.push(`High noise levels (${highNoiseStressed.length} instances) often correlated with stress (${noiseStressCorrelation}% of the time).`);\r\n    }\r\n\r\n    // Time-based patterns\r\n    const morningEntries = moodEntries.filter(entry => {\r\n      const hour = new Date(entry.timestamp).getHours();\r\n      return hour >= 6 && hour < 12;\r\n    });\r\n    const afternoonEntries = moodEntries.filter(entry => {\r\n      const hour = new Date(entry.timestamp).getHours();\r\n      return hour >= 12 && hour < 18;\r\n    });\r\n    const eveningEntries = moodEntries.filter(entry => {\r\n      const hour = new Date(entry.timestamp).getHours();\r\n      return hour >= 18 || hour < 6;\r\n    });\r\n\r\n    const timeInsights = this.analyzeTimePatterns(morningEntries, afternoonEntries, eveningEntries);\r\n    if (timeInsights) {\r\n      insights.push(timeInsights);\r\n    }\r\n\r\n    // Location clustering\r\n    const locationInsights = this.analyzeLocationPatterns(moodEntries);\r\n    if (locationInsights) {\r\n      insights.push(locationInsights);\r\n    }\r\n\r\n    return insights.join(' ');\r\n  }\r\n\r\n  // Analyze time-based mood patterns\r\n  private static analyzeTimePatterns(\r\n    morning: MoodEntry[],\r\n    afternoon: MoodEntry[],\r\n    evening: MoodEntry[]\r\n  ): string | null {\r\n    const periods = [\r\n      { name: 'morning', entries: morning },\r\n      { name: 'afternoon', entries: afternoon },\r\n      { name: 'evening', entries: evening }\r\n    ];\r\n\r\n    const periodStressRates = periods.map(period => ({\r\n      name: period.name,\r\n      stressRate: period.entries.length > 0 \r\n        ? period.entries.filter(e => e.mood === 'stressed').length / period.entries.length\r\n        : 0\r\n    }));\r\n\r\n    const bestPeriod = periodStressRates.reduce((best, current) => \r\n      current.stressRate < best.stressRate ? current : best\r\n    );\r\n    const worstPeriod = periodStressRates.reduce((worst, current) => \r\n      current.stressRate > worst.stressRate ? current : worst\r\n    );\r\n\r\n    if (bestPeriod.stressRate < 0.2 && worstPeriod.stressRate > 0.4) {\r\n      return `Consider walking more in the ${bestPeriod.name} when stress levels are lower.`;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  // Analyze location-based patterns\r\n  private static analyzeLocationPatterns(entries: MoodEntry[]): string | null {\r\n    if (entries.length < 3) return null;\r\n\r\n    // Group nearby entries (within 50 meters)\r\n    const clusters = this.clusterNearbyEntries(entries, 50);\r\n    \r\n    const clusterMoods = clusters.map(cluster => ({\r\n      center: cluster.center,\r\n      entries: cluster.entries,\r\n      stressRate: cluster.entries.filter(e => e.mood === 'stressed').length / cluster.entries.length,\r\n      calmRate: cluster.entries.filter(e => e.mood === 'calm').length / cluster.entries.length\r\n    }));\r\n\r\n    const stressClusters = clusterMoods.filter(c => c.stressRate > 0.6);\r\n    const calmClusters = clusterMoods.filter(c => c.calmRate > 0.6);\r\n\r\n    if (stressClusters.length > 0) {\r\n      return `Some areas consistently triggered stress. Consider avoiding these locations.`;\r\n    }\r\n\r\n    if (calmClusters.length > 0) {\r\n      return `Some areas consistently provided calm moments. These might be good rest spots.`;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  // Cluster nearby mood entries\r\n  private static clusterNearbyEntries(entries: MoodEntry[], radiusMeters: number) {\r\n    const clusters: Array<{ center: Location; entries: MoodEntry[] }> = [];\r\n    const processed = new Set<string>();\r\n\r\n    entries.forEach(entry => {\r\n      if (processed.has(entry.id)) return;\r\n\r\n      const cluster = {\r\n        center: entry.location,\r\n        entries: [entry]\r\n      };\r\n\r\n      // Find nearby entries\r\n      entries.forEach(otherEntry => {\r\n        if (otherEntry.id === entry.id || processed.has(otherEntry.id)) return;\r\n        \r\n        if (GPSService.calculateDistance(entry.location, otherEntry.location) <= radiusMeters) {\r\n          cluster.entries.push(otherEntry);\r\n          processed.add(otherEntry.id);\r\n        }\r\n      });\r\n\r\n      processed.add(entry.id);\r\n      clusters.push(cluster);\r\n    });\r\n\r\n    return clusters;\r\n  }\r\n\r\n  // Update calm and stress zones based on session data\r\n  static updateZonesFromSession(\r\n    session: WalkSession,\r\n    existingCalmZones: CalmZone[],\r\n    existingStressZones: StressZone[]\r\n  ): { calmZones: CalmZone[]; stressZones: StressZone[] } {\r\n    const calmZones = [...existingCalmZones];\r\n    const stressZones = [...existingStressZones];\r\n\r\n    // Group entries by location clusters\r\n    const clusters = this.clusterNearbyEntries(session.moodEntries, 30);\r\n    \r\n    clusters.forEach(cluster => {\r\n      const stressRate = cluster.entries.filter(e => e.mood === 'stressed').length / cluster.entries.length;\r\n      const calmRate = cluster.entries.filter(e => e.mood === 'calm').length / cluster.entries.length;\r\n      \r\n      if (stressRate > 0.6 && cluster.entries.length >= 2) {\r\n        // This is a stress zone\r\n        const existingZone = stressZones.find(zone => \r\n          GPSService.calculateDistance(zone.center, cluster.center) < 50\r\n        );\r\n        \r\n        if (existingZone) {\r\n          existingZone.stressCount += cluster.entries.length;\r\n          existingZone.stressScore = Math.min(1, existingZone.stressScore + 0.1);\r\n          existingZone.lastStressed = Math.max(existingZone.lastStressed, \r\n            Math.max(...cluster.entries.map(e => e.timestamp))\r\n          );\r\n        } else {\r\n          stressZones.push({\r\n            id: `stress_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n            center: cluster.center,\r\n            radius: 30,\r\n            stressScore: stressRate,\r\n            stressCount: cluster.entries.length,\r\n            lastStressed: Math.max(...cluster.entries.map(e => e.timestamp))\r\n          });\r\n        }\r\n      } else if (calmRate > 0.6 && cluster.entries.length >= 2) {\r\n        // This is a calm zone\r\n        const existingZone = calmZones.find(zone => \r\n          GPSService.calculateDistance(zone.center, cluster.center) < 50\r\n        );\r\n        \r\n        if (existingZone) {\r\n          existingZone.visitCount += cluster.entries.length;\r\n          existingZone.calmScore = Math.min(1, existingZone.calmScore + 0.1);\r\n          existingZone.lastVisited = Math.max(existingZone.lastVisited, \r\n            Math.max(...cluster.entries.map(e => e.timestamp))\r\n          );\r\n        } else {\r\n          calmZones.push({\r\n            id: `calm_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n            center: cluster.center,\r\n            radius: 30,\r\n            calmScore: calmRate,\r\n            visitCount: cluster.entries.length,\r\n            lastVisited: Math.max(...cluster.entries.map(e => e.timestamp))\r\n          });\r\n        }\r\n      }\r\n    });\r\n\r\n    return { calmZones, stressZones };\r\n  }\r\n\r\n  // Generate route suggestions\r\n  static generateRouteSuggestion(\r\n    start: Location,\r\n    end: Location,\r\n    calmZones: CalmZone[],\r\n    stressZones: StressZone[]\r\n  ) {\r\n    // Simple route suggestion algorithm\r\n    // In a real implementation, this would use a proper routing service\r\n    \r\n    const waypoints: Location[] = [];\r\n    let calmScore = 0.5; // Base score\r\n    \r\n    // Try to include calm zones along the route\r\n    const nearbyCalmZones = calmZones.filter(zone => {\r\n      const distToStart = GPSService.calculateDistance(start, zone.center);\r\n      const distToEnd = GPSService.calculateDistance(end, zone.center);\r\n      return distToStart < 200 && distToEnd < 200;\r\n    });\r\n    \r\n    if (nearbyCalmZones.length > 0) {\r\n      const bestCalmZone = nearbyCalmZones.reduce((best, current) => \r\n        current.calmScore > best.calmScore ? current : best\r\n      );\r\n      waypoints.push(bestCalmZone.center);\r\n      calmScore += bestCalmZone.calmScore * 0.3;\r\n    }\r\n    \r\n    // Avoid stress zones\r\n    const nearbyStressZones = stressZones.filter(zone => {\r\n      const distToStart = GPSService.calculateDistance(start, zone.center);\r\n      const distToEnd = GPSService.calculateDistance(end, zone.center);\r\n      return distToStart < 200 && distToEnd < 200;\r\n    });\r\n    \r\n    calmScore -= nearbyStressZones.length * 0.2;\r\n    \r\n    // Calculate estimated duration (rough approximation)\r\n    const totalDistance = GPSService.calculateDistance(start, end);\r\n    const estimatedDuration = Math.round(totalDistance / 1000 * 12); // ~12 min per km walking\r\n    \r\n    return {\r\n      id: `route_${Date.now()}`,\r\n      start,\r\n      end,\r\n      waypoints,\r\n      calmScore: Math.max(0, Math.min(1, calmScore)),\r\n      estimatedDuration,\r\n      avoidsStressZones: nearbyStressZones.map(zone => zone.id),\r\n      includesCalmZones: nearbyCalmZones.map(zone => zone.id)\r\n    };\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}