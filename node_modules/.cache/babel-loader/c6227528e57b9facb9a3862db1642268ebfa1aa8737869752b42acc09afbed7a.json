{"ast":null,"code":"export class AudioService{constructor(onNoiseUpdate){this.audioContext=null;this.analyser=null;this.microphone=null;this.dataArray=null;this.animationFrame=null;this.onNoiseUpdate=null;this.onNoiseUpdate=onNoiseUpdate;}async startRecording(){try{// Request microphone access\nconst stream=await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:true,noiseSuppression:true,autoGainControl:true}});// Create audio context\nthis.audioContext=new(window.AudioContext||window.webkitAudioContext)();this.analyser=this.audioContext.createAnalyser();this.microphone=this.audioContext.createMediaStreamSource(stream);// Configure analyser\nthis.analyser.fftSize=256;this.analyser.smoothingTimeConstant=0.8;this.microphone.connect(this.analyser);// Create data array\nconst bufferLength=this.analyser.frequencyBinCount;this.dataArray=new Uint8Array(bufferLength);// Start monitoring\nthis.monitorNoiseLevel();return true;}catch(error){console.error('Failed to start audio recording:',error);return false;}}stopRecording(){if(this.animationFrame){cancelAnimationFrame(this.animationFrame);this.animationFrame=null;}if(this.microphone){this.microphone.disconnect();this.microphone=null;}if(this.analyser){this.analyser.disconnect();this.analyser=null;}if(this.audioContext){this.audioContext.close();this.audioContext=null;}this.dataArray=null;}monitorNoiseLevel(){if(!this.analyser||!this.dataArray)return;const updateNoiseLevel=()=>{var _this$onNoiseUpdate;this.analyser.getByteFrequencyData(this.dataArray);// Calculate RMS (Root Mean Square) for noise level\nlet sum=0;for(let i=0;i<this.dataArray.length;i++){sum+=this.dataArray[i]*this.dataArray[i];}const rms=Math.sqrt(sum/this.dataArray.length);// Convert to decibels (approximate)\nconst noiseLevel=rms>0?20*Math.log10(rms/255)+60:0;(_this$onNoiseUpdate=this.onNoiseUpdate)===null||_this$onNoiseUpdate===void 0?void 0:_this$onNoiseUpdate.call(this,Math.max(0,noiseLevel));this.animationFrame=requestAnimationFrame(updateNoiseLevel);};updateNoiseLevel();}// Get current noise level without continuous monitoring\nasync getCurrentNoiseLevel(){try{const stream=await navigator.mediaDevices.getUserMedia({audio:true});const audioContext=new(window.AudioContext||window.webkitAudioContext)();const analyser=audioContext.createAnalyser();const microphone=audioContext.createMediaStreamSource(stream);analyser.fftSize=256;microphone.connect(analyser);const bufferLength=analyser.frequencyBinCount;const dataArray=new Uint8Array(bufferLength);return new Promise(resolve=>{const getNoiseLevel=()=>{analyser.getByteFrequencyData(dataArray);let sum=0;for(let i=0;i<dataArray.length;i++){sum+=dataArray[i]*dataArray[i];}const rms=Math.sqrt(sum/dataArray.length);const noiseLevel=rms>0?20*Math.log10(rms/255)+60:0;// Clean up\nmicrophone.disconnect();analyser.disconnect();audioContext.close();stream.getTracks().forEach(track=>track.stop());resolve(Math.max(0,noiseLevel));};// Wait a bit for the analyser to collect data\nsetTimeout(getNoiseLevel,100);});}catch(error){console.error('Failed to get noise level:',error);return 0;}}// Convert noise level to human-readable description\nstatic getNoiseDescription(noiseLevel){if(noiseLevel<30)return'Very Quiet';if(noiseLevel<40)return'Quiet';if(noiseLevel<50)return'Moderate';if(noiseLevel<60)return'Loud';if(noiseLevel<70)return'Very Loud';return'Extremely Loud';}// Check if noise level is potentially stressful\nstatic isStressfulNoise(noiseLevel){return noiseLevel>60;// Above 60dB is considered potentially stressful\n}}","map":{"version":3,"names":["AudioService","constructor","onNoiseUpdate","audioContext","analyser","microphone","dataArray","animationFrame","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","echoCancellation","noiseSuppression","autoGainControl","window","AudioContext","webkitAudioContext","createAnalyser","createMediaStreamSource","fftSize","smoothingTimeConstant","connect","bufferLength","frequencyBinCount","Uint8Array","monitorNoiseLevel","error","console","stopRecording","cancelAnimationFrame","disconnect","close","updateNoiseLevel","_this$onNoiseUpdate","getByteFrequencyData","sum","i","length","rms","Math","sqrt","noiseLevel","log10","call","max","requestAnimationFrame","getCurrentNoiseLevel","Promise","resolve","getNoiseLevel","getTracks","forEach","track","stop","setTimeout","getNoiseDescription","isStressfulNoise"],"sources":["C:/Users/usman/.cursor/alzense/src/services/audio.ts"],"sourcesContent":["export class AudioService {\r\n  private audioContext: AudioContext | null = null;\r\n  private analyser: AnalyserNode | null = null;\r\n  private microphone: MediaStreamAudioSourceNode | null = null;\r\n  private dataArray: Uint8Array | null = null;\r\n  private animationFrame: number | null = null;\r\n  private onNoiseUpdate: ((noiseLevel: number) => void) | null = null;\r\n\r\n  constructor(onNoiseUpdate: (noiseLevel: number) => void) {\r\n    this.onNoiseUpdate = onNoiseUpdate;\r\n  }\r\n\r\n  async startRecording(): Promise<boolean> {\r\n    try {\r\n      // Request microphone access\r\n      const stream = await navigator.mediaDevices.getUserMedia({\r\n        audio: {\r\n          echoCancellation: true,\r\n          noiseSuppression: true,\r\n          autoGainControl: true\r\n        }\r\n      });\r\n\r\n      // Create audio context\r\n      this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\r\n      this.analyser = this.audioContext.createAnalyser();\r\n      this.microphone = this.audioContext.createMediaStreamSource(stream);\r\n\r\n      // Configure analyser\r\n      this.analyser.fftSize = 256;\r\n      this.analyser.smoothingTimeConstant = 0.8;\r\n      this.microphone.connect(this.analyser);\r\n\r\n      // Create data array\r\n      const bufferLength = this.analyser.frequencyBinCount;\r\n      this.dataArray = new Uint8Array(bufferLength);\r\n\r\n      // Start monitoring\r\n      this.monitorNoiseLevel();\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Failed to start audio recording:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  stopRecording(): void {\r\n    if (this.animationFrame) {\r\n      cancelAnimationFrame(this.animationFrame);\r\n      this.animationFrame = null;\r\n    }\r\n\r\n    if (this.microphone) {\r\n      this.microphone.disconnect();\r\n      this.microphone = null;\r\n    }\r\n\r\n    if (this.analyser) {\r\n      this.analyser.disconnect();\r\n      this.analyser = null;\r\n    }\r\n\r\n    if (this.audioContext) {\r\n      this.audioContext.close();\r\n      this.audioContext = null;\r\n    }\r\n\r\n    this.dataArray = null;\r\n  }\r\n\r\n  private monitorNoiseLevel(): void {\r\n    if (!this.analyser || !this.dataArray) return;\r\n\r\n    const updateNoiseLevel = () => {\r\n      this.analyser!.getByteFrequencyData(this.dataArray!);\r\n      \r\n      // Calculate RMS (Root Mean Square) for noise level\r\n      let sum = 0;\r\n      for (let i = 0; i < this.dataArray!.length; i++) {\r\n        sum += this.dataArray![i] * this.dataArray![i];\r\n      }\r\n      const rms = Math.sqrt(sum / this.dataArray!.length);\r\n      \r\n      // Convert to decibels (approximate)\r\n      const noiseLevel = rms > 0 ? 20 * Math.log10(rms / 255) + 60 : 0;\r\n      \r\n      this.onNoiseUpdate?.(Math.max(0, noiseLevel));\r\n      \r\n      this.animationFrame = requestAnimationFrame(updateNoiseLevel);\r\n    };\r\n\r\n    updateNoiseLevel();\r\n  }\r\n\r\n  // Get current noise level without continuous monitoring\r\n  async getCurrentNoiseLevel(): Promise<number> {\r\n    try {\r\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n      const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\r\n      const analyser = audioContext.createAnalyser();\r\n      const microphone = audioContext.createMediaStreamSource(stream);\r\n\r\n      analyser.fftSize = 256;\r\n      microphone.connect(analyser);\r\n\r\n      const bufferLength = analyser.frequencyBinCount;\r\n      const dataArray = new Uint8Array(bufferLength);\r\n\r\n      return new Promise((resolve) => {\r\n        const getNoiseLevel = () => {\r\n          analyser.getByteFrequencyData(dataArray);\r\n          \r\n          let sum = 0;\r\n          for (let i = 0; i < dataArray.length; i++) {\r\n            sum += dataArray[i] * dataArray[i];\r\n          }\r\n          const rms = Math.sqrt(sum / dataArray.length);\r\n          const noiseLevel = rms > 0 ? 20 * Math.log10(rms / 255) + 60 : 0;\r\n          \r\n          // Clean up\r\n          microphone.disconnect();\r\n          analyser.disconnect();\r\n          audioContext.close();\r\n          stream.getTracks().forEach(track => track.stop());\r\n          \r\n          resolve(Math.max(0, noiseLevel));\r\n        };\r\n\r\n        // Wait a bit for the analyser to collect data\r\n        setTimeout(getNoiseLevel, 100);\r\n      });\r\n    } catch (error) {\r\n      console.error('Failed to get noise level:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  // Convert noise level to human-readable description\r\n  static getNoiseDescription(noiseLevel: number): string {\r\n    if (noiseLevel < 30) return 'Very Quiet';\r\n    if (noiseLevel < 40) return 'Quiet';\r\n    if (noiseLevel < 50) return 'Moderate';\r\n    if (noiseLevel < 60) return 'Loud';\r\n    if (noiseLevel < 70) return 'Very Loud';\r\n    return 'Extremely Loud';\r\n  }\r\n\r\n  // Check if noise level is potentially stressful\r\n  static isStressfulNoise(noiseLevel: number): boolean {\r\n    return noiseLevel > 60; // Above 60dB is considered potentially stressful\r\n  }\r\n}\r\n"],"mappings":"AAAA,MAAO,MAAM,CAAAA,YAAa,CAQxBC,WAAWA,CAACC,aAA2C,CAAE,MAPjDC,YAAY,CAAwB,IAAI,MACxCC,QAAQ,CAAwB,IAAI,MACpCC,UAAU,CAAsC,IAAI,MACpDC,SAAS,CAAsB,IAAI,MACnCC,cAAc,CAAkB,IAAI,MACpCL,aAAa,CAA0C,IAAI,CAGjE,IAAI,CAACA,aAAa,CAAGA,aAAa,CACpC,CAEA,KAAM,CAAAM,cAAcA,CAAA,CAAqB,CACvC,GAAI,CACF;AACA,KAAM,CAAAC,MAAM,CAAG,KAAM,CAAAC,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC,CACvDC,KAAK,CAAE,CACLC,gBAAgB,CAAE,IAAI,CACtBC,gBAAgB,CAAE,IAAI,CACtBC,eAAe,CAAE,IACnB,CACF,CAAC,CAAC,CAEF;AACA,IAAI,CAACb,YAAY,CAAG,IAAKc,MAAM,CAACC,YAAY,EAAKD,MAAM,CAASE,kBAAkB,EAAE,CAAC,CACrF,IAAI,CAACf,QAAQ,CAAG,IAAI,CAACD,YAAY,CAACiB,cAAc,CAAC,CAAC,CAClD,IAAI,CAACf,UAAU,CAAG,IAAI,CAACF,YAAY,CAACkB,uBAAuB,CAACZ,MAAM,CAAC,CAEnE;AACA,IAAI,CAACL,QAAQ,CAACkB,OAAO,CAAG,GAAG,CAC3B,IAAI,CAAClB,QAAQ,CAACmB,qBAAqB,CAAG,GAAG,CACzC,IAAI,CAAClB,UAAU,CAACmB,OAAO,CAAC,IAAI,CAACpB,QAAQ,CAAC,CAEtC;AACA,KAAM,CAAAqB,YAAY,CAAG,IAAI,CAACrB,QAAQ,CAACsB,iBAAiB,CACpD,IAAI,CAACpB,SAAS,CAAG,GAAI,CAAAqB,UAAU,CAACF,YAAY,CAAC,CAE7C;AACA,IAAI,CAACG,iBAAiB,CAAC,CAAC,CAExB,MAAO,KAAI,CACb,CAAE,MAAOC,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,kCAAkC,CAAEA,KAAK,CAAC,CACxD,MAAO,MAAK,CACd,CACF,CAEAE,aAAaA,CAAA,CAAS,CACpB,GAAI,IAAI,CAACxB,cAAc,CAAE,CACvByB,oBAAoB,CAAC,IAAI,CAACzB,cAAc,CAAC,CACzC,IAAI,CAACA,cAAc,CAAG,IAAI,CAC5B,CAEA,GAAI,IAAI,CAACF,UAAU,CAAE,CACnB,IAAI,CAACA,UAAU,CAAC4B,UAAU,CAAC,CAAC,CAC5B,IAAI,CAAC5B,UAAU,CAAG,IAAI,CACxB,CAEA,GAAI,IAAI,CAACD,QAAQ,CAAE,CACjB,IAAI,CAACA,QAAQ,CAAC6B,UAAU,CAAC,CAAC,CAC1B,IAAI,CAAC7B,QAAQ,CAAG,IAAI,CACtB,CAEA,GAAI,IAAI,CAACD,YAAY,CAAE,CACrB,IAAI,CAACA,YAAY,CAAC+B,KAAK,CAAC,CAAC,CACzB,IAAI,CAAC/B,YAAY,CAAG,IAAI,CAC1B,CAEA,IAAI,CAACG,SAAS,CAAG,IAAI,CACvB,CAEQsB,iBAAiBA,CAAA,CAAS,CAChC,GAAI,CAAC,IAAI,CAACxB,QAAQ,EAAI,CAAC,IAAI,CAACE,SAAS,CAAE,OAEvC,KAAM,CAAA6B,gBAAgB,CAAGA,CAAA,GAAM,KAAAC,mBAAA,CAC7B,IAAI,CAAChC,QAAQ,CAAEiC,oBAAoB,CAAC,IAAI,CAAC/B,SAAU,CAAC,CAEpD;AACA,GAAI,CAAAgC,GAAG,CAAG,CAAC,CACX,IAAK,GAAI,CAAAC,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAG,IAAI,CAACjC,SAAS,CAAEkC,MAAM,CAAED,CAAC,EAAE,CAAE,CAC/CD,GAAG,EAAI,IAAI,CAAChC,SAAS,CAAEiC,CAAC,CAAC,CAAG,IAAI,CAACjC,SAAS,CAAEiC,CAAC,CAAC,CAChD,CACA,KAAM,CAAAE,GAAG,CAAGC,IAAI,CAACC,IAAI,CAACL,GAAG,CAAG,IAAI,CAAChC,SAAS,CAAEkC,MAAM,CAAC,CAEnD;AACA,KAAM,CAAAI,UAAU,CAAGH,GAAG,CAAG,CAAC,CAAG,EAAE,CAAGC,IAAI,CAACG,KAAK,CAACJ,GAAG,CAAG,GAAG,CAAC,CAAG,EAAE,CAAG,CAAC,CAEhE,CAAAL,mBAAA,KAAI,CAAClC,aAAa,UAAAkC,mBAAA,iBAAlBA,mBAAA,CAAAU,IAAA,KAAI,CAAiBJ,IAAI,CAACK,GAAG,CAAC,CAAC,CAAEH,UAAU,CAAC,CAAC,CAE7C,IAAI,CAACrC,cAAc,CAAGyC,qBAAqB,CAACb,gBAAgB,CAAC,CAC/D,CAAC,CAEDA,gBAAgB,CAAC,CAAC,CACpB,CAEA;AACA,KAAM,CAAAc,oBAAoBA,CAAA,CAAoB,CAC5C,GAAI,CACF,KAAM,CAAAxC,MAAM,CAAG,KAAM,CAAAC,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC,CAAEC,KAAK,CAAE,IAAK,CAAC,CAAC,CACzE,KAAM,CAAAV,YAAY,CAAG,IAAKc,MAAM,CAACC,YAAY,EAAKD,MAAM,CAASE,kBAAkB,EAAE,CAAC,CACtF,KAAM,CAAAf,QAAQ,CAAGD,YAAY,CAACiB,cAAc,CAAC,CAAC,CAC9C,KAAM,CAAAf,UAAU,CAAGF,YAAY,CAACkB,uBAAuB,CAACZ,MAAM,CAAC,CAE/DL,QAAQ,CAACkB,OAAO,CAAG,GAAG,CACtBjB,UAAU,CAACmB,OAAO,CAACpB,QAAQ,CAAC,CAE5B,KAAM,CAAAqB,YAAY,CAAGrB,QAAQ,CAACsB,iBAAiB,CAC/C,KAAM,CAAApB,SAAS,CAAG,GAAI,CAAAqB,UAAU,CAACF,YAAY,CAAC,CAE9C,MAAO,IAAI,CAAAyB,OAAO,CAAEC,OAAO,EAAK,CAC9B,KAAM,CAAAC,aAAa,CAAGA,CAAA,GAAM,CAC1BhD,QAAQ,CAACiC,oBAAoB,CAAC/B,SAAS,CAAC,CAExC,GAAI,CAAAgC,GAAG,CAAG,CAAC,CACX,IAAK,GAAI,CAAAC,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGjC,SAAS,CAACkC,MAAM,CAAED,CAAC,EAAE,CAAE,CACzCD,GAAG,EAAIhC,SAAS,CAACiC,CAAC,CAAC,CAAGjC,SAAS,CAACiC,CAAC,CAAC,CACpC,CACA,KAAM,CAAAE,GAAG,CAAGC,IAAI,CAACC,IAAI,CAACL,GAAG,CAAGhC,SAAS,CAACkC,MAAM,CAAC,CAC7C,KAAM,CAAAI,UAAU,CAAGH,GAAG,CAAG,CAAC,CAAG,EAAE,CAAGC,IAAI,CAACG,KAAK,CAACJ,GAAG,CAAG,GAAG,CAAC,CAAG,EAAE,CAAG,CAAC,CAEhE;AACApC,UAAU,CAAC4B,UAAU,CAAC,CAAC,CACvB7B,QAAQ,CAAC6B,UAAU,CAAC,CAAC,CACrB9B,YAAY,CAAC+B,KAAK,CAAC,CAAC,CACpBzB,MAAM,CAAC4C,SAAS,CAAC,CAAC,CAACC,OAAO,CAACC,KAAK,EAAIA,KAAK,CAACC,IAAI,CAAC,CAAC,CAAC,CAEjDL,OAAO,CAACT,IAAI,CAACK,GAAG,CAAC,CAAC,CAAEH,UAAU,CAAC,CAAC,CAClC,CAAC,CAED;AACAa,UAAU,CAACL,aAAa,CAAE,GAAG,CAAC,CAChC,CAAC,CAAC,CACJ,CAAE,MAAOvB,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,4BAA4B,CAAEA,KAAK,CAAC,CAClD,MAAO,EAAC,CACV,CACF,CAEA;AACA,MAAO,CAAA6B,mBAAmBA,CAACd,UAAkB,CAAU,CACrD,GAAIA,UAAU,CAAG,EAAE,CAAE,MAAO,YAAY,CACxC,GAAIA,UAAU,CAAG,EAAE,CAAE,MAAO,OAAO,CACnC,GAAIA,UAAU,CAAG,EAAE,CAAE,MAAO,UAAU,CACtC,GAAIA,UAAU,CAAG,EAAE,CAAE,MAAO,MAAM,CAClC,GAAIA,UAAU,CAAG,EAAE,CAAE,MAAO,WAAW,CACvC,MAAO,gBAAgB,CACzB,CAEA;AACA,MAAO,CAAAe,gBAAgBA,CAACf,UAAkB,CAAW,CACnD,MAAO,CAAAA,UAAU,CAAG,EAAE,CAAE;AAC1B,CACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}