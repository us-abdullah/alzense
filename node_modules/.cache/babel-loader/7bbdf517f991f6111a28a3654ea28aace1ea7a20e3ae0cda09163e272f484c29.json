{"ast":null,"code":"export class AudioService {\n  constructor(onNoiseUpdate) {\n    this.audioContext = null;\n    this.analyser = null;\n    this.microphone = null;\n    this.dataArray = null;\n    this.animationFrame = null;\n    this.onNoiseUpdate = null;\n    this.onNoiseUpdate = onNoiseUpdate;\n  }\n  async startRecording() {\n    try {\n      // Request microphone access\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          echoCancellation: true,\n          noiseSuppression: true,\n          autoGainControl: true\n        }\n      });\n\n      // Create audio context\n      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n      this.analyser = this.audioContext.createAnalyser();\n      this.microphone = this.audioContext.createMediaStreamSource(stream);\n\n      // Configure analyser\n      this.analyser.fftSize = 256;\n      this.analyser.smoothingTimeConstant = 0.8;\n      this.microphone.connect(this.analyser);\n\n      // Create data array\n      const bufferLength = this.analyser.frequencyBinCount;\n      this.dataArray = new Uint8Array(bufferLength);\n\n      // Start monitoring\n      this.monitorNoiseLevel();\n      return true;\n    } catch (error) {\n      console.error('Failed to start audio recording:', error);\n      return false;\n    }\n  }\n  stopRecording() {\n    if (this.animationFrame) {\n      cancelAnimationFrame(this.animationFrame);\n      this.animationFrame = null;\n    }\n    if (this.microphone) {\n      this.microphone.disconnect();\n      this.microphone = null;\n    }\n    if (this.analyser) {\n      this.analyser.disconnect();\n      this.analyser = null;\n    }\n    if (this.audioContext) {\n      this.audioContext.close();\n      this.audioContext = null;\n    }\n    this.dataArray = null;\n  }\n  monitorNoiseLevel() {\n    if (!this.analyser || !this.dataArray) return;\n    const updateNoiseLevel = () => {\n      var _this$onNoiseUpdate;\n      this.analyser.getByteFrequencyData(this.dataArray);\n\n      // Calculate RMS (Root Mean Square) for noise level\n      let sum = 0;\n      for (let i = 0; i < this.dataArray.length; i++) {\n        sum += this.dataArray[i] * this.dataArray[i];\n      }\n      const rms = Math.sqrt(sum / this.dataArray.length);\n\n      // Convert to decibels (approximate)\n      const noiseLevel = rms > 0 ? 20 * Math.log10(rms / 255) + 60 : 0;\n      (_this$onNoiseUpdate = this.onNoiseUpdate) === null || _this$onNoiseUpdate === void 0 ? void 0 : _this$onNoiseUpdate.call(this, Math.max(0, noiseLevel));\n      this.animationFrame = requestAnimationFrame(updateNoiseLevel);\n    };\n    updateNoiseLevel();\n  }\n\n  // Get current noise level without continuous monitoring\n  async getCurrentNoiseLevel() {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n      const analyser = audioContext.createAnalyser();\n      const microphone = audioContext.createMediaStreamSource(stream);\n      analyser.fftSize = 256;\n      microphone.connect(analyser);\n      const bufferLength = analyser.frequencyBinCount;\n      const dataArray = new Uint8Array(bufferLength);\n      return new Promise(resolve => {\n        const getNoiseLevel = () => {\n          analyser.getByteFrequencyData(dataArray);\n          let sum = 0;\n          for (let i = 0; i < dataArray.length; i++) {\n            sum += dataArray[i] * dataArray[i];\n          }\n          const rms = Math.sqrt(sum / dataArray.length);\n          const noiseLevel = rms > 0 ? 20 * Math.log10(rms / 255) + 60 : 0;\n\n          // Clean up\n          microphone.disconnect();\n          analyser.disconnect();\n          audioContext.close();\n          stream.getTracks().forEach(track => track.stop());\n          resolve(Math.max(0, noiseLevel));\n        };\n\n        // Wait a bit for the analyser to collect data\n        setTimeout(getNoiseLevel, 100);\n      });\n    } catch (error) {\n      console.error('Failed to get noise level:', error);\n      return 0;\n    }\n  }\n\n  // Convert noise level to human-readable description\n  static getNoiseDescription(noiseLevel) {\n    if (noiseLevel < 30) return 'Very Quiet';\n    if (noiseLevel < 40) return 'Quiet';\n    if (noiseLevel < 50) return 'Moderate';\n    if (noiseLevel < 60) return 'Loud';\n    if (noiseLevel < 70) return 'Very Loud';\n    return 'Extremely Loud';\n  }\n\n  // Check if noise level is potentially stressful\n  static isStressfulNoise(noiseLevel) {\n    return noiseLevel > 60; // Above 60dB is considered potentially stressful\n  }\n}","map":{"version":3,"names":["AudioService","constructor","onNoiseUpdate","audioContext","analyser","microphone","dataArray","animationFrame","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","echoCancellation","noiseSuppression","autoGainControl","window","AudioContext","webkitAudioContext","createAnalyser","createMediaStreamSource","fftSize","smoothingTimeConstant","connect","bufferLength","frequencyBinCount","Uint8Array","monitorNoiseLevel","error","console","stopRecording","cancelAnimationFrame","disconnect","close","updateNoiseLevel","_this$onNoiseUpdate","getByteFrequencyData","sum","i","length","rms","Math","sqrt","noiseLevel","log10","call","max","requestAnimationFrame","getCurrentNoiseLevel","Promise","resolve","getNoiseLevel","getTracks","forEach","track","stop","setTimeout","getNoiseDescription","isStressfulNoise"],"sources":["C:/Users/usman/.cursor/alzense/src/services/audio.ts"],"sourcesContent":["export class AudioService {\r\n  private audioContext: AudioContext | null = null;\r\n  private analyser: AnalyserNode | null = null;\r\n  private microphone: MediaStreamAudioSourceNode | null = null;\r\n  private dataArray: Uint8Array | null = null;\r\n  private animationFrame: number | null = null;\r\n  private onNoiseUpdate: ((noiseLevel: number) => void) | null = null;\r\n\r\n  constructor(onNoiseUpdate: (noiseLevel: number) => void) {\r\n    this.onNoiseUpdate = onNoiseUpdate;\r\n  }\r\n\r\n  async startRecording(): Promise<boolean> {\r\n    try {\r\n      // Request microphone access\r\n      const stream = await navigator.mediaDevices.getUserMedia({\r\n        audio: {\r\n          echoCancellation: true,\r\n          noiseSuppression: true,\r\n          autoGainControl: true\r\n        }\r\n      });\r\n\r\n      // Create audio context\r\n      this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\r\n      this.analyser = this.audioContext.createAnalyser();\r\n      this.microphone = this.audioContext.createMediaStreamSource(stream);\r\n\r\n      // Configure analyser\r\n      this.analyser.fftSize = 256;\r\n      this.analyser.smoothingTimeConstant = 0.8;\r\n      this.microphone.connect(this.analyser);\r\n\r\n      // Create data array\r\n      const bufferLength = this.analyser.frequencyBinCount;\r\n      this.dataArray = new Uint8Array(bufferLength);\r\n\r\n      // Start monitoring\r\n      this.monitorNoiseLevel();\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Failed to start audio recording:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  stopRecording(): void {\r\n    if (this.animationFrame) {\r\n      cancelAnimationFrame(this.animationFrame);\r\n      this.animationFrame = null;\r\n    }\r\n\r\n    if (this.microphone) {\r\n      this.microphone.disconnect();\r\n      this.microphone = null;\r\n    }\r\n\r\n    if (this.analyser) {\r\n      this.analyser.disconnect();\r\n      this.analyser = null;\r\n    }\r\n\r\n    if (this.audioContext) {\r\n      this.audioContext.close();\r\n      this.audioContext = null;\r\n    }\r\n\r\n    this.dataArray = null;\r\n  }\r\n\r\n  private monitorNoiseLevel(): void {\r\n    if (!this.analyser || !this.dataArray) return;\r\n\r\n    const updateNoiseLevel = () => {\r\n      this.analyser!.getByteFrequencyData(this.dataArray!);\r\n      \r\n      // Calculate RMS (Root Mean Square) for noise level\r\n      let sum = 0;\r\n      for (let i = 0; i < this.dataArray!.length; i++) {\r\n        sum += this.dataArray![i] * this.dataArray![i];\r\n      }\r\n      const rms = Math.sqrt(sum / this.dataArray!.length);\r\n      \r\n      // Convert to decibels (approximate)\r\n      const noiseLevel = rms > 0 ? 20 * Math.log10(rms / 255) + 60 : 0;\r\n      \r\n      this.onNoiseUpdate?.(Math.max(0, noiseLevel));\r\n      \r\n      this.animationFrame = requestAnimationFrame(updateNoiseLevel);\r\n    };\r\n\r\n    updateNoiseLevel();\r\n  }\r\n\r\n  // Get current noise level without continuous monitoring\r\n  async getCurrentNoiseLevel(): Promise<number> {\r\n    try {\r\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n      const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\r\n      const analyser = audioContext.createAnalyser();\r\n      const microphone = audioContext.createMediaStreamSource(stream);\r\n\r\n      analyser.fftSize = 256;\r\n      microphone.connect(analyser);\r\n\r\n      const bufferLength = analyser.frequencyBinCount;\r\n      const dataArray = new Uint8Array(bufferLength);\r\n\r\n      return new Promise((resolve) => {\r\n        const getNoiseLevel = () => {\r\n          analyser.getByteFrequencyData(dataArray);\r\n          \r\n          let sum = 0;\r\n          for (let i = 0; i < dataArray.length; i++) {\r\n            sum += dataArray[i] * dataArray[i];\r\n          }\r\n          const rms = Math.sqrt(sum / dataArray.length);\r\n          const noiseLevel = rms > 0 ? 20 * Math.log10(rms / 255) + 60 : 0;\r\n          \r\n          // Clean up\r\n          microphone.disconnect();\r\n          analyser.disconnect();\r\n          audioContext.close();\r\n          stream.getTracks().forEach(track => track.stop());\r\n          \r\n          resolve(Math.max(0, noiseLevel));\r\n        };\r\n\r\n        // Wait a bit for the analyser to collect data\r\n        setTimeout(getNoiseLevel, 100);\r\n      });\r\n    } catch (error) {\r\n      console.error('Failed to get noise level:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  // Convert noise level to human-readable description\r\n  static getNoiseDescription(noiseLevel: number): string {\r\n    if (noiseLevel < 30) return 'Very Quiet';\r\n    if (noiseLevel < 40) return 'Quiet';\r\n    if (noiseLevel < 50) return 'Moderate';\r\n    if (noiseLevel < 60) return 'Loud';\r\n    if (noiseLevel < 70) return 'Very Loud';\r\n    return 'Extremely Loud';\r\n  }\r\n\r\n  // Check if noise level is potentially stressful\r\n  static isStressfulNoise(noiseLevel: number): boolean {\r\n    return noiseLevel > 60; // Above 60dB is considered potentially stressful\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}